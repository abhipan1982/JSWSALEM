using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Kendo.Mvc.Extensions;
using Kendo.Mvc.UI;
using Microsoft.AspNetCore.Mvc.ModelBinding;
using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;
using Opc.UaFx.Client;
using PE.BaseDbEntity.EFCoreExtensions;
using PE.BaseDbEntity.EnumClasses;
using PE.BaseDbEntity.Models;
using PE.BaseDbEntity.PEContext;
using PE.DbEntity.PEContext;
using PE.HMIWWW.Areas.MillConfigurator.ViewModels.AssetTemplate;
using PE.HMIWWW.Areas.MillConfigurator.ViewModels.MillConfiguration;
using PE.HMIWWW.Core.Extensions;
using PE.HMIWWW.Core.Parameter;
using PE.HMIWWW.Core.Resources;
using PE.HMIWWW.Core.ViewModel;
using PE.HMIWWW.Services.System;
using SMF.Core.OPCClient;
using SMF.DbEntity.Models;

namespace PE.HMIWWW.Areas.MillConfigurator.Services
{
  public class MillConfigurationService
  {
    public MillConfigurationService() { }

    public async Task ValidateStandardAssets(PEContext ctx)
    {
      var assets = await ctx.MVHAssets
        .IgnoreQueryFilters()
        .ToListAsync();

      if (assets.Any())
        return;

      var orderSeq = -1;

      var areas = GetRestrictedAreas();

      foreach (var item in areas)
      {
        orderSeq++;
        await ctx.MVHAssets.AddAsync(new MVHAsset
        {
          OrderSeq = orderSeq,
          AssetCode = item.Key,
          AssetName = item.Value,
          AssetDescription = "Asset autogenerated",
          FKParentAssetId = null,
          FKAssetTypeId = null,
          IsActive = item.Key != 0,
          IsArea = (item.Key % 1000000 != 0) && item.Key != TrackingArea.Undefined,
          IsZone = (item.Key % 1000000 == 0 || item.Key == TrackingArea.PLANT) && item.Key != TrackingArea.Undefined,
          IsTrackingPoint = item.Key != 0,
          IsDelayCheckpoint = false,
          IsReversible = false,
          EnumTrackingAreaType = TrackingAreaType.Collection,
          IsPositionBased = false,
          PositionsNumber = 1,
          VirtualPositionsNumber = 1,
          IsVisibleOnMVH = false
        });
      }

      await ctx.SaveChangesAsync();

      assets = await ctx.MVHAssets
        .IgnoreQueryFilters()
        .ToListAsync();


      foreach (var item in assets)
      {
        if (!item.IsZone && item.AssetCode > TrackingArea.Undefined)
          item.FKParentAssetId = assets
            .OrderByDescending(x => x.AssetCode)
            .FirstOrDefault(x => x.AssetCode < item.AssetCode && x.IsZone && x.AssetCode > TrackingArea.Undefined)?.AssetId;
        else if (item.IsZone && item.AssetCode > TrackingArea.PLANT)
          item.FKParentAssetId = assets.First(x => x.AssetCode == TrackingArea.PLANT).AssetId;
      }

      await ctx.SaveChangesAsync();
    }

    public async Task<VM_AssetInstance> GetAssetByIdAsync(PEContext peCtx, long assetId)
    {
      var data = new VM_AssetInstance(await peCtx.MVHAssets
        .IgnoreQueryFilters()
        .FirstAsync(x => x.AssetId == assetId));

      var parentAsset = GetAssetList(peCtx);
      var assetType = GetAssetTypeList(peCtx);

      data.ParentAssetName = parentAsset.FirstOrDefault(x => x.AssetId == data.FKParentAssetId)?.AssetName;
      data.AssetType = assetType.FirstOrDefault(x => x.AssetTypeId == data.FKAssetTypeId)?.AssetTypeName;

      return data;
    }

    public async Task<VM_FeatureInstance> GetFeatureByIdAsync(PEContext peCtx, long featureId)
    {
      var data = new VM_FeatureInstance(await peCtx.MVHFeatures
        .IgnoreQueryFilters()
        .Include(x => x.FKDataType)
        .Include(x => x.FKAsset)
        .Include(x => x.FKParentFeature)
        .FirstAsync(x => x.FeatureId == featureId));

      await using var smfCtx = new SMFContext();

      var uom = GetUnitOfMeasureList(smfCtx);
      data.UnitOfMeasureSymbol = uom.First(x => x.UnitId == data.FKUnitOfMeasureId).UnitSymbol;
      data.ExtUnitOfMeasureSymbol = uom.First(x => x.UnitId == data.FKExtUnitOfMeasureId).UnitSymbol;

      return data;
    }

    public async Task<VM_AssetType> GetAssetTypeByIdAsync(PEContext peCtx, long assetTypeId)
    {
      return new VM_AssetType(await peCtx.MVHAssetTypes
        .FirstAsync(x => x.AssetTypeId == assetTypeId));
    }

    public TreeDataSourceResult GetAssignedAssetsTreeList(HmiContext ctx, DataSourceRequest request)
    {
      return ctx.V_Assets
        .Where(x => x.AssetCode > 0)
        .IgnoreQueryFilters()
        .AsNoTracking()
        .ToListAsync().GetAwaiter().GetResult()
        .ToTreeDataSourceResultAsync(request,
          e => e.AssetId,
          e => e.ParentAssetId,
          e => e).GetAwaiter().GetResult();
    }

    public DataSourceResult GetAssignedFeaturesListAsync(HmiContext ctx, DataSourceRequest request)
    {
      return ctx.V_Features
        .Where(x => x.AssetSeq > 0)
        .OrderBy(x => x.OrderSeq)
        .ToListAsync().GetAwaiter().GetResult()
        .ToDataSourceLocalResult(request, data => new VM_FeatureInstance(data));
    }

    public async Task<VM_FeaturesToPdf> GetAssignedFeaturesListForPDFAsync(HmiContext ctx)
    {
      var features = await ctx.V_Features
        .Where(x => x.AssetSeq > 0 && x.IsActive)
        .OrderBy(x => x.OrderSeq)
        .Where(x => x.EnumFeatureProvider == FeatureProvider.L1.Value)
        .Select(x => new VM_FeatureInstance(x))
        .ToListAsync();

      var assets = await ctx.V_Assets
        .Where(x => x.OrderSeq > 0 && x.IsActive && (x.IsArea || x.IsZone))
        .OrderBy(x => x.OrderSeq)
        .Select(x => new VM_AssetTree(x))
        .ToListAsync();

      var projectName = ParameterController.GetParameter("ProjectName")?.ValueText ?? "";

      return new VM_FeaturesToPdf(features, assets, projectName);
    }

    public TreeDataSourceResult GetUnassignedAssetsTreeList(PEContext ctx, DataSourceRequest request)
    {
      var data = ctx.MVHAssets
        .Where(x => x.AssetCode < 0)
        .IgnoreQueryFilters()
        .AsNoTracking()
        .ToListAsync().GetAwaiter().GetResult();

      if (!data.Any())
      {
        data.Add(new MVHAsset
        {
          AssetName = ResourceController.GetResourceTextByResourceKey("NAME_Empty"),
          OrderSeq = -1,
          EnumTrackingAreaType = TrackingAreaType.None,
          AssetId = 0
        });
      }

      return data.ToTreeDataSourceResultAsync(request,
          e => e.AssetId,
          e => e.FKParentAssetId,
          e => e).GetAwaiter().GetResult();
    }

    public DataSourceResult GetAssignedFeatureSearchList(PEContext peCtx, DataSourceRequest request, long assetId)
    {
      return peCtx.MVHFeatures
        .IgnoreQueryFilters()
        .Where(x => x.FKAssetId == assetId)
        .Include(x => x.FKAsset)
        .Include(x => x.FKParentFeature)
        .ToListAsync().GetAwaiter().GetResult()
        .ToDataSourceLocalResult(request, data => new VM_FeatureInstance(data));
    }

    public async Task<VM_Base> CreateAssetAsync(ModelStateDictionary modelState, PEContext ctx, VM_AssetInstance data)
    {
      var result = new VM_Base();

      await CheckAssetUniqueNameAsync(ctx, modelState, data.AssetName);

      if (!modelState.IsValid)
        return result;

      var assetTemplate = await GetAssetTemplateAsync(ctx, data.AssetTemplateId.Value);
      var featureTemplates = await GetFeatureTemplatesByAssetTemplateAsync(ctx, data.AssetTemplateId.Value);
      var assets = await GetAssetsAsync(ctx);
      var lowestAssetSeq = GetLowestNumber(assets.Select(x => x.OrderSeq));
      var lowestAssetCode = GetLowestNumber(assets.Select(x => x.AssetCode));

      var asset = new MVHAsset
      {
        OrderSeq = lowestAssetSeq,
        AssetCode = lowestAssetCode,
        AssetName = data.AssetName,
        AssetDescription = data.AssetDescription,
        FKParentAssetId = null,
        FKAssetTypeId = data.FKAssetTypeId,
        IsActive = data.IsActive,
        IsArea = assetTemplate.IsArea,
        IsZone = assetTemplate.IsZone,
        IsTrackingPoint = data.IsTrackingPoint,
        IsDelayCheckpoint = data.IsDelayCheckpoint,
        IsReversible = data.IsReversible,
        EnumTrackingAreaType = assetTemplate.EnumTrackingAreaType,
        IsPositionBased = false,
        PositionsNumber = null,
        VirtualPositionsNumber = null,
        IsVisibleOnMVH = false,
      };

      await ctx.MVHAssets.AddAsync(asset);
      await CreateFeaturesForAssetFromTemplatesAsync(ctx, featureTemplates, asset);

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> CreateAreaAsync(ModelStateDictionary modelState, PEContext ctx, VM_AssetInstance data)
    {
      var result = new VM_Base();

      await CheckAssetUniqueNameAsync(ctx, modelState, data.AssetName);

      if (!modelState.IsValid)
        return result;

      var assetTemplate = await GetAssetTemplateAsync(ctx, data.AssetTemplateId.Value);
      var featureTemplates = await GetFeatureTemplatesByAssetTemplateAsync(ctx, data.AssetTemplateId.Value);
      var assets = await GetAssetsAsync(ctx);
      var lowestAssetSeq = GetLowestNumber(assets.Select(x => x.OrderSeq));
      var lowestAssetCode = GetLowestNumber(assets.Select(x => x.AssetCode));

      var asset = new MVHAsset
      {
        OrderSeq = lowestAssetSeq,
        AssetCode = lowestAssetCode,
        AssetName = data.AssetName,
        AssetDescription = data.AssetDescription,
        FKParentAssetId = null,
        FKAssetTypeId = data.FKAssetTypeId,
        IsActive = data.IsActive,
        IsArea = assetTemplate.IsArea,
        IsZone = assetTemplate.IsZone,
        IsTrackingPoint = data.IsTrackingPoint,
        IsDelayCheckpoint = data.IsDelayCheckpoint,
        IsReversible = data.IsReversible,
        EnumTrackingAreaType = assetTemplate.EnumTrackingAreaType,
        IsPositionBased = data.IsPositionBased,
        PositionsNumber = data.PositionsNumber,
        VirtualPositionsNumber = data.VirtualPositionsNumber,
        IsVisibleOnMVH = data.IsVisibleOnMVH
      };

      await ctx.MVHAssets.AddAsync(asset);
      await CreateFeaturesForAssetFromTemplatesAsync(ctx, featureTemplates, asset);

      await ctx.SaveChangesAsync();

      await UpdateCustomEnumsAsync(asset);

      return result;
    }

    public async Task<VM_Base> CreateAssetTypeAsync(ModelStateDictionary modelState, PEContext ctx, VM_AssetType data)
    {
      var result = new VM_Base();

      await CheckAssetTypeUniqueNameAsync(ctx, modelState, data.AssetTypeName);
      await CheckAssetTypeUniqueCodeAsync(ctx, modelState, data.AssetTypeName);

      if (!modelState.IsValid)
      {
        return result;
      }

      await ctx.MVHAssetTypes.AddAsync(new MVHAssetType
      {
        AssetTypeCode = data.AssetTypeCode,
        AssetTypeName = data.AssetTypeName,
        AssetTypeDescription = data.AssetTypeDescription,
        EnumYardType = YardType.GetValue(data.EnumYardType)
      });

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> EditAssetTypeAsync(ModelStateDictionary modelState, PEContext ctx, VM_AssetType data)
    {
      var result = new VM_Base();

      var assetType = await ctx.MVHAssetTypes.FirstAsync(x => x.AssetTypeId == data.AssetTypeId);

      await CheckAssetTypeUniqueNameAsync(ctx, modelState, data.AssetTypeName, data.AssetTypeId);
      await CheckAssetTypeUniqueCodeAsync(ctx, modelState, data.AssetTypeName, data.AssetTypeId);

      if (!modelState.IsValid)
        return result;

      assetType.AssetTypeCode = data.AssetTypeCode;
      assetType.AssetTypeName = data.AssetTypeName;
      assetType.AssetTypeDescription = data.AssetTypeDescription;
      assetType.EnumYardType = YardType.GetValue(data.EnumYardType);

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> DeleteAssetTypeAsync(PEContext ctx, long assetTypeId)
    {
      var result = new VM_Base();

      var assets = await GetAssetsByAssetTypeAsync(ctx, assetTypeId);

      if (assets.Any())
      {
        foreach (var item in assets)
        {
          item.FKAssetTypeId = null;
        }

        await ctx.SaveChangesAsync();
      }

      var assetType = await ctx.MVHAssetTypes
        .FirstAsync(x => x.AssetTypeId == assetTypeId);

      ctx.MVHAssetTypes.Remove(assetType);

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> EditAssetAsync(ModelStateDictionary modelState, PEContext ctx, VM_AssetInstance data)
    {
      var result = new VM_Base();

      await CheckAssetUniqueNameAsync(ctx, modelState, data.AssetName, data.AssetId);

      if (!modelState.IsValid)
        return result;

      var asset = await GetAssetAsync(ctx, data.AssetId, true);

      foreach (var item in asset.MVHFeatures)
      {
        item.FeatureName = item.FeatureName.Replace(asset.AssetName, data.AssetName);
        item.CommAttr2 = item.CommAttr2?.Replace(asset.AssetName, data.AssetName);
        item.IsActive = data.IsActive;
      }

      asset.AssetName = data.AssetName;
      asset.FKAssetTypeId = data.FKAssetTypeId;
      asset.AssetDescription = data.AssetDescription;
      asset.IsActive = data.IsActive;
      asset.IsTrackingPoint = data.IsTrackingPoint;
      asset.IsDelayCheckpoint = data.IsDelayCheckpoint;
      asset.IsPositionBased = data.IsPositionBased;
      asset.PositionsNumber = data.PositionsNumber;
      asset.VirtualPositionsNumber = data.VirtualPositionsNumber;
      asset.IsReversible = data.IsReversible;

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> EditAreaAsync(ModelStateDictionary modelState, PEContext ctx, VM_AssetInstance data)
    {
      var result = new VM_Base();

      await CheckAssetUniqueNameAsync(ctx, modelState, data.AssetName, data.AssetId);

      if (!modelState.IsValid)
        return result;

      var asset = await GetAssetAsync(ctx, data.AssetId, true);

      foreach (var item in asset.MVHFeatures)
      {
        item.FeatureName = item.FeatureName.Replace(asset.AssetName, data.AssetName);
        item.CommAttr2 = item.CommAttr2?.Replace(asset.AssetName, data.AssetName);
        item.IsActive = data.IsActive;
      }

      asset.AssetName = data.AssetName;
      asset.FKAssetTypeId = data.FKAssetTypeId;
      asset.AssetDescription = data.AssetDescription;
      asset.IsActive = data.IsActive;
      asset.IsTrackingPoint = data.IsTrackingPoint;
      asset.IsDelayCheckpoint = data.IsDelayCheckpoint;
      asset.IsPositionBased = data.IsPositionBased;
      asset.PositionsNumber = data.PositionsNumber;
      asset.VirtualPositionsNumber = data.VirtualPositionsNumber;
      asset.IsReversible = data.IsReversible;
      asset.IsVisibleOnMVH = data.IsVisibleOnMVH;
      asset.EnumTrackingAreaType = TrackingAreaType.GetValue(data.EnumTrackingAreaType);

      await ctx.SaveChangesAsync();

      //return view model
      return result;
    }

    public async Task<VM_Base> CloneAssetAsync(ModelStateDictionary modelState, PEContext ctx, VM_AssetInstance data)
    {
      var result = new VM_Base();

      await CheckAssetUniqueNameAsync(ctx, modelState, data.AssetName);

      if (!modelState.IsValid)
        return result;

      var assets = await GetAssetsAsync(ctx);
      var asset = assets.First(x => x.AssetId == data.AssetId);
      var lowestAssetSeq = GetLowestNumber(assets.Select(x => x.OrderSeq));
      var lowestAssetCode = GetLowestNumber(assets.Select(x => x.AssetCode));

      var newAsset = new MVHAsset
      {
        OrderSeq = lowestAssetSeq,
        AssetCode = lowestAssetCode,
        AssetName = data.AssetName,
        AssetDescription = data.AssetDescription,
        FKParentAssetId = null,
        FKAssetTypeId = data.FKAssetTypeId,
        IsActive = data.IsActive,
        IsArea = asset.IsArea,
        IsZone = asset.IsZone,
        IsTrackingPoint = data.IsTrackingPoint,
        IsDelayCheckpoint = data.IsDelayCheckpoint,
        IsReversible = data.IsReversible,
        EnumTrackingAreaType = asset.EnumTrackingAreaType,
        IsPositionBased = false,
        PositionsNumber = null,
        VirtualPositionsNumber = null
      };

      await ctx.MVHAssets.AddAsync(newAsset);
      await CreateFeaturesForAssetAsync(ctx, newAsset, data.AssetId, asset.AssetName);

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> CloneAreaAsync(ModelStateDictionary modelState, PEContext ctx, VM_AssetInstance data)
    {
      var result = new VM_Base();

      await CheckAssetUniqueNameAsync(ctx, modelState, data.AssetName);

      if (!modelState.IsValid)
      {
        return result;
      }

      var assets = await GetAssetsAsync(ctx);
      var asset = assets.First(x => x.AssetId == data.AssetId);

      var lowestAssetSeq = GetLowestNumber(assets.Select(x => x.OrderSeq));
      var lowestAssetCode = GetLowestNumber(assets.Select(x => x.AssetCode));

      var newAsset = new MVHAsset
      {
        OrderSeq = lowestAssetSeq,
        AssetCode = lowestAssetCode,
        AssetName = data.AssetName,
        AssetDescription = data.AssetDescription,
        FKParentAssetId = null,
        FKAssetTypeId = data.FKAssetTypeId,
        IsActive = data.IsActive,
        IsArea = asset.IsArea,
        IsZone = asset.IsZone,
        IsTrackingPoint = data.IsTrackingPoint,
        IsDelayCheckpoint = data.IsDelayCheckpoint,
        IsReversible = data.IsReversible,
        EnumTrackingAreaType = asset.EnumTrackingAreaType,
        IsPositionBased = data.IsPositionBased,
        PositionsNumber = data.PositionsNumber,
        VirtualPositionsNumber = data.VirtualPositionsNumber,
        IsVisibleOnMVH = data.IsVisibleOnMVH
      };

      await ctx.MVHAssets.AddAsync(newAsset);
      await CreateFeaturesForAssetAsync(ctx, newAsset, data.AssetId, asset.AssetName);

      await ctx.SaveChangesAsync();

      await using var smfCtx = new SMFContext();
      await smfCtx.EnumValues.AddAsync(new EnumValue
      {
        FkEnumNameId = 121,
        Keyword = newAsset.AssetName,
        Value = newAsset.AssetCode,
        IsCustom = true
      });

      await smfCtx.SaveChangesAsync();

      //return view model
      return result;
    }

    public async Task<VM_Base> DeleteAssetAsync(PEContext ctx, long assetId)
    {
      var result = new VM_Base();

      var assetWithChildren = await ctx.MVHAssets
        .IgnoreQueryFilters()
        .Include(x => x.MVHFeatures)
        .Where(x => x.AssetId == assetId || x.FKParentAssetId == assetId)
        .ToListAsync();

      var assetIds = new List<long>();
      assetIds.AddRange(assetWithChildren.Select(x => x.AssetId).ToList());
      var featureIds = new List<long>();
      featureIds.AddRange(assetWithChildren.First(x => x.AssetId == assetId).MVHFeatures.Select(x => x.FeatureId).ToList());

      foreach (var child in assetWithChildren.Where(x => x.AssetId != assetId))
      {
        child.FKParentAssetId = null;
      }

      await RemoveRelations(ctx, featureIds, assetIds);

      await ctx.SaveChangesAsync();

      ctx.MVHFeatures.RemoveRange(ctx.MVHFeatures.IgnoreQueryFilters().Where(x => featureIds.Contains(x.FeatureId)));
      var asset = assetWithChildren.First(x => x.AssetId == assetId);
      ctx.MVHAssets.Remove(asset);

      await ctx.SaveChangesAsync();

      if (asset.IsZone || asset.IsArea)
      {
        await using var smfCtx = new SMFContext();
        var enumToRemove = await smfCtx.EnumValues.FirstOrDefaultAsync(x => x.FkEnumNameId == 121 && x.IsCustom && x.Value == asset.AssetCode);
        if (enumToRemove is not null)
        {
          smfCtx.Remove(enumToRemove);
          await smfCtx.SaveChangesAsync();
        }
      }

      return result;
    }

    public async Task<VM_Base> CreateFeatureAsync(ModelStateDictionary modelState, PEContext ctx, VM_FeatureInstance data)
    {
      var result = new VM_Base();

      await CheckFeatureUniqueNameAsync(ctx, modelState, data.FeatureName);

      if (!modelState.IsValid)
        return result;

      var asset = await GetAssetAsync(ctx, data.FKAssetId, true);

      var featureCode = 0;

      if (asset.AssetCode < 0)
        featureCode = GetLowestNumber((await GetFeaturesAsync(ctx)).Select(x => x.FeatureCode));
      else
      {
        var gap = 2;
        var maxAssetCode = (asset.MVHFeatures
          .OrderBy(x => x.FeatureCode)
          .FirstOrDefault()?.FeatureCode ?? asset.AssetCode) + 50;

        var assetCode = asset.AssetCode + gap;

        for (var i = assetCode; i < maxAssetCode; i++)
        {
          if (i % gap > 0)
            continue;

          if (asset.MVHFeatures.Any(x => x.FeatureCode == i))
            continue;

          featureCode = i;
          break;
        }
      }

      await ctx.MVHFeatures.AddAsync(new MVHFeature
      {
        FKAssetId = data.FKAssetId,
        FKUnitOfMeasureId = data.FKUnitOfMeasureId,
        FKExtUnitOfMeasureId = data.FKExtUnitOfMeasureId,
        FKDataTypeId = data.FKDataTypeId,
        FKParentFeatureId = data.FKParentFeatureId,
        FeatureCode = featureCode,
        FeatureName = data.FeatureName,
        FeatureDescription = data.FeatureDescription,
        IsSampledFeature = data.IsSampledFeature,
        IsMaterialRelated = data.IsMaterialRelated,
        IsLengthRelated = data.IsLengthRelated,
        IsQETrigger = data.IsQETrigger,
        IsDigital = data.IsDigital,
        IsActive = data.IsActive,
        IsOnHMI = data.IsOnHMI,
        SampleOffsetTime = data.SampleOffsetTime,
        ConsumptionAggregationTime = data.ConsumptionAggregationTime,
        MinValue = data.MinValue,
        MaxValue = data.MaxValue,
        RetentionFactor = data.RetentionFactor,
        EnumFeatureType = FeatureType.GetValue(data.EnumFeatureType),
        EnumCommChannelType = CommChannelType.GetValue(data.EnumCommChannelType),
        EnumAggregationStrategy = AggregationStrategy.GetValue(data.EnumAggregationStrategy),
        EnumFeatureProvider = FeatureProvider.GetValue(data.EnumFeatureProvider),
        EnumTagValidationResult = TagValidationResult.Undefined,
        CommAttr1 = data.CommAttr1,
        CommAttr2 = data.CommAttr2,
        CommAttr3 = data.CommAttr3,
      });

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> EditFeatureAsync(ModelStateDictionary modelState, PEContext ctx, VM_FeatureInstance data)
    {
      var result = new VM_Base();

      await CheckFeatureUniqueNameAsync(ctx, modelState, data.FeatureName, data.FeatureId);

      if (!modelState.IsValid)
        return result;

      var feature = await GetFeatureAsync(ctx, data.FeatureId);

      feature.FKAssetId = data.FKAssetId;
      feature.FKUnitOfMeasureId = data.FKUnitOfMeasureId;
      feature.FKExtUnitOfMeasureId = data.FKExtUnitOfMeasureId;
      feature.FKDataTypeId = data.FKDataTypeId;
      feature.FKParentFeatureId = data.FKParentFeatureId;
      feature.FeatureName = data.FeatureName;
      feature.FeatureDescription = data.FeatureDescription;
      feature.IsSampledFeature = data.IsSampledFeature;
      feature.IsMaterialRelated = data.IsMaterialRelated;
      feature.IsLengthRelated = data.IsLengthRelated;
      feature.IsQETrigger = data.IsQETrigger;
      feature.IsDigital = data.IsDigital;
      feature.IsActive = data.IsActive;
      feature.IsOnHMI = data.IsOnHMI;
      feature.SampleOffsetTime = data.SampleOffsetTime;
      feature.ConsumptionAggregationTime = data.ConsumptionAggregationTime;
      feature.MinValue = data.MinValue;
      feature.MaxValue = data.MaxValue;
      feature.RetentionFactor = data.RetentionFactor;
      feature.EnumFeatureType = FeatureType.GetValue(data.EnumFeatureType);
      feature.EnumCommChannelType = CommChannelType.GetValue(data.EnumCommChannelType);
      feature.EnumAggregationStrategy = AggregationStrategy.GetValue(data.EnumAggregationStrategy);
      feature.EnumFeatureProvider = FeatureProvider.GetValue(data.EnumFeatureProvider);
      feature.EnumTagValidationResult = TagValidationResult.Undefined;
      feature.CommAttr1 = data.CommAttr1;
      feature.CommAttr2 = data.CommAttr2;
      feature.CommAttr3 = data.CommAttr3;

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> DeleteFeatureAsync(PEContext ctx, long featureId)
    {
      var result = new VM_Base();

      await RemoveRelations(ctx, new List<long> { featureId }, new List<long>());

      ctx.MVHFeatures.Remove(await GetFeatureAsync(ctx, featureId));

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> ReorderAssignedAssetsAsync(PEContext ctx, long dragAssetId, long dropAssetId, long? parentAssetId, short dropMode)
    {
      var result = new VM_Base();

      var assets = await ctx.MVHAssets
        .Where(x => x.OrderSeq > 0)
        .IgnoreQueryFilters()
        .Include(x => x.MVHFeatures)
        .ToListAsync();

      var asset = assets.First(x => x.AssetId == dragAssetId);

      if (asset.FKParentAssetId != parentAssetId)
      {
        var featureIds = asset.MVHFeatures.Select(x => x.FeatureId).ToList();
        var assetIds = new List<long>
        {
          asset.AssetId
        };

        assets.First(x => x.AssetId == dragAssetId).FKParentAssetId = parentAssetId;

        var children = GetChildrenAssets(assets, dragAssetId);
        await UpdateAssetCode(ctx, assets, dragAssetId);
        UpdateFeatureCode(assets.First(x => x.AssetId == dragAssetId));

        foreach (var item in children)
        {
          await UpdateAssetCode(ctx, assets, item.AssetId);
          UpdateFeatureCode(item);
          featureIds.AddRange(item.MVHFeatures.Select(x => x.FeatureId));
          assetIds.Add(item.AssetId);
        }
      }

      await ctx.SaveChangesAsync();

      var orderSeq = await ctx.MVHAssets
        .Where(x => x.OrderSeq > 0)
        .IgnoreQueryFilters()
        .OrderBy(x => x.OrderSeq)
        .Select(x => x.AssetId)
        .ToListAsync();

      if (dropMode == 1 || dropMode == 3)
      {
        orderSeq.RemoveAt(orderSeq.IndexOf(dragAssetId));
        orderSeq.Insert(orderSeq.IndexOf(dropAssetId) + 1, dragAssetId);
      }
      else if (dropMode == 2)
      {
        orderSeq.RemoveAt(orderSeq.IndexOf(dragAssetId));
        orderSeq.Insert(orderSeq.IndexOf(dropAssetId), dragAssetId);
      }

      await UpdateOrderSequence(ctx, orderSeq, assets, dragAssetId);
      await UpdateEnumsAsync(assets);

      return result;
    }

    public async Task<VM_Base> ReorderUnassignedAssetsAsync(PEContext ctx, long dragAssetId, long? parentAssetId)
    {
      var result = new VM_Base();

      var unassignedAssets = await ctx.MVHAssets
        .Where(x => x.OrderSeq < 0)
        .IgnoreQueryFilters()
        .Include(x => x.MVHFeatures)
        .ToListAsync();

      unassignedAssets.First(x => x.AssetId == dragAssetId).FKParentAssetId = parentAssetId;
      var minFeatureCode = GetLowestNumber((await GetFeaturesAsync(ctx)).Select(x => x.FeatureCode));

      UpdateFeatureCode(unassignedAssets.First(x => x.AssetId == dragAssetId), minFeatureCode);
      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> AssignAssetAsync(ModelStateDictionary modelState, PEContext ctx, long dragAssetId, long dropAssetId)
    {
      var result = new VM_Base();

      var assets = await GetAssetsAsync(ctx, true);
      var children = GetChildrenAssets(assets, dragAssetId);

      assets = assets
        .Where(x => x.OrderSeq > 0 || x.AssetId == dragAssetId || children.Select(y => y.AssetId).Contains(x.AssetId))
        .ToList();

      assets.First(x => x.AssetId == dragAssetId).FKParentAssetId = dropAssetId;
      var maxOrderSeq = assets.Max(x => x.OrderSeq) + 1;
      assets.First(x => x.AssetId == dragAssetId).OrderSeq = maxOrderSeq;
      maxOrderSeq++;

      await UpdateAssetCode(ctx, assets, dragAssetId);
      UpdateFeatureCode(assets.First(x => x.AssetId == dragAssetId));

      foreach (var item in GetChildrenAssets(assets, dragAssetId))
      {
        await UpdateAssetCode(ctx, assets, item.AssetId);
        item.OrderSeq = maxOrderSeq;
        maxOrderSeq++;

        UpdateFeatureCode(item);
      }

      await ctx.SaveChangesAsync();

      var orderSeq = await ctx.MVHAssets
        .Where(x => x.OrderSeq > 0)
        .IgnoreQueryFilters()
        .OrderBy(x => x.OrderSeq)
        .Select(x => x.AssetId)
        .ToListAsync();

      orderSeq.RemoveAt(orderSeq.IndexOf(dragAssetId));
      orderSeq.Insert(orderSeq.IndexOf(dropAssetId) + 1, dragAssetId);

      await UpdateOrderSequence(ctx, orderSeq, assets, dragAssetId);
      await UpdateEnumsAsync(assets);

      return result;
    }

    public async Task<VM_Base> UnassignAssetAsync(ModelStateDictionary modelState, PEContext ctx, long dragAssetId)
    {
      var result = new VM_Base();

      var assets = await GetAssetsAsync(ctx, true);
      var children = GetChildrenAssets(assets, dragAssetId);
      var lowestOrderSeq = GetLowestNumber(assets.Select(x => x.OrderSeq));
      var lowestAssetCode = GetLowestNumber(assets.Select(x => x.AssetCode));

      assets = assets
        .Where(x => x.AssetId == dragAssetId || children.Select(y => y.AssetId).Contains(x.AssetId))
        .ToList();

      assets.First(x => x.AssetId == dragAssetId).FKParentAssetId = null;

      if (GetRestrictedAreas().Select(x => x.Key).ToList().Contains(assets.First(x => x.AssetId == dragAssetId).AssetCode))
        modelState.AddModelError("error", ResourceController.GetErrorText("CannotUnassignRestrictedAsset"));

      if (!modelState.IsValid)
        return result;

      var lowestFeatureCode = GetLowestNumber((await GetFeaturesAsync(ctx)).Select(x => x.FeatureCode));

      var featureIds = new List<long>();
      var assetIds = assets.Select(x => x.AssetId).ToList();

      foreach (var item in assets)
      {
        item.AssetCode = lowestAssetCode;
        item.OrderSeq = lowestOrderSeq;

        lowestAssetCode--;
        lowestOrderSeq--;

        UpdateFeatureCode(item, lowestFeatureCode);
        lowestFeatureCode--;
        featureIds.AddRange(item.MVHFeatures.Select(x => x.FeatureId));
      }

      await RemoveRelations(ctx, featureIds, assetIds);

      await ctx.SaveChangesAsync();

      var sequence = await ctx.MVHAssets
        .IgnoreQueryFilters()
        .Where(x => x.OrderSeq > 0)
        .OrderBy(x => x.OrderSeq)
        .Select(x => x.AssetId)
        .ToListAsync();

      await UpdateOrderSequence(ctx, sequence, assets, null);
      await UpdateEnumsAsync(assets);

      return result;
    }

    public async Task<VM_Base> VerifyFeaturesAsync(PEContext ctx)
    {
      var result = new VM_Base();

      var features = await ctx.MVHFeatures
        .Where(x => x.EnumFeatureProvider == FeatureProvider.L1 && x.CommAttr1 != null)
        .ToListAsync();

      var opcAddresses = features.Select(x => x.CommAttr1).Distinct();
      var featureValidatorList = new List<VM_FeatureValidator>();

      foreach (var item in opcAddresses)
      {
        featureValidatorList.Add(new VM_FeatureValidator()
        {
          ServerAddress = item,
          AssignedFeatures = features.Where(x => x.CommAttr1.Equals(item)).Select(x => new VM_FeatureInstance(x)).ToList(),
          UnassignedFeatures = features.Where(x => !x.CommAttr1.Equals(item)).Select(x => new VM_FeatureInstance(x)).ToList(),
        });

        try
        {
          var customOpcClient = new CustomOpcClient(item);
          customOpcClient.Init(operationTimeout: 5000, disconnectTimeout: 100, reconnectTimeout: 500);
          customOpcClient.CertificateConfigure();
          customOpcClient.Connect();

          var tags = features
            .Where(x => x.CommAttr1.Equals(item))
            .Select(x => x.CommAttr2)
            .ToList();

          foreach (var assignedFeature in featureValidatorList.LastOrDefault().AssignedFeatures)
          {
            try
            {
              var nodeInfo = customOpcClient.OpcClientObject.BrowseNode(assignedFeature.CommAttr2);
              if (string.IsNullOrEmpty(nodeInfo.Name.Value) || string.IsNullOrEmpty(nodeInfo.DisplayName.Value))
                assignedFeature.EnumTagValidationResult = TagValidationResult.NotFound;
              else
                assignedFeature.EnumTagValidationResult = TagValidationResult.Valid;
            }
            catch (Exception)
            {
              assignedFeature.EnumTagValidationResult = TagValidationResult.NotFound;
            }
          }

          foreach (var unassignedFeature in featureValidatorList.LastOrDefault().UnassignedFeatures)
          {
            try
            {
              var nodeInfo = customOpcClient.OpcClientObject.BrowseNode(unassignedFeature.CommAttr2);
              if (string.IsNullOrEmpty(nodeInfo.Name.Value) || string.IsNullOrEmpty(nodeInfo.DisplayName.Value))
                unassignedFeature.EnumTagValidationResult = TagValidationResult.NotFound;
              else
                unassignedFeature.EnumTagValidationResult = TagValidationResult.AvailableOnAnotherServer;
            }
            catch (Exception)
            {
              unassignedFeature.EnumTagValidationResult = TagValidationResult.NotFound;
            }
          }
        }
        catch (Exception)
        {
          foreach (var incorrectAssignedFeature in featureValidatorList.LastOrDefault().AssignedFeatures)
          {
            incorrectAssignedFeature.EnumTagValidationResult = TagValidationResult.OpcServerNotAvailable;
          }
          foreach (var incorrectUnassignedFeature in featureValidatorList.LastOrDefault().UnassignedFeatures)
          {
            incorrectUnassignedFeature.EnumTagValidationResult = TagValidationResult.NotFound;
          }
        }
      }

      foreach (var feature in features)
      {
        var featureInCorrectServer = featureValidatorList
          .FirstOrDefault(x => x.ServerAddress.Equals(feature.CommAttr1))
          ?.AssignedFeatures.FirstOrDefault(x => x.FeatureId == feature.FeatureId);
        var featuresInIncorrectServer = featureValidatorList
          .Where(x => !x.ServerAddress.Equals(feature.CommAttr1))
          .SelectMany(x => x.UnassignedFeatures.Where(y => y.FeatureId == feature.FeatureId));

        if (featureInCorrectServer is null)
          feature.EnumTagValidationResult = TagValidationResult.NotFound;
        else if (featureInCorrectServer.EnumTagValidationResult == TagValidationResult.GetValue(TagValidationResult.Valid))
          feature.EnumTagValidationResult = TagValidationResult.Valid;
        else if (featuresInIncorrectServer.Any(x => x.EnumTagValidationResult == TagValidationResult.GetValue(TagValidationResult.AvailableOnAnotherServer)))
          feature.EnumTagValidationResult = TagValidationResult.AvailableOnAnotherServer;
        else if (featureInCorrectServer.EnumTagValidationResult == TagValidationResult.GetValue(TagValidationResult.OpcServerNotAvailable))
          feature.EnumTagValidationResult = TagValidationResult.OpcServerNotAvailable;
        else
          feature.EnumTagValidationResult = TagValidationResult.NotFound;
      }

      await ctx.SaveChangesAsync();

      return result;
    }

    public async Task<VM_Base> ExportFeaturesToPDFAsync(HmiContext ctx, IViewToStringRendererService renderService, string viewName)
    {
      VM_Base result = new VM_Base();

      await renderService.RenderViewToStringAsync(viewName,
        GetAssignedFeaturesListForPDFAsync(ctx));

      return result;
    }

    public IList<VM_AssetTemplate> GetAssetTemplateList(PEContext peCtx)
    {
      return peCtx.MVHAssetTemplates
        .Where(x => !x.IsZone && !x.IsArea)
        .Select(x => new VM_AssetTemplate(x))
        .ToList();
    }

    public IList<VM_AssetTemplate> GetAreaTemplateList(PEContext peCtx)
    {
      return peCtx.MVHAssetTemplates
        .Where(x => x.IsZone || x.IsArea)
        .Select(x => new VM_AssetTemplate(x))
        .ToList();
    }

    public IList<MVHAssetType> GetAssetTypeList(PEContext peCtx)
    {
      return peCtx.MVHAssetTypes.ToList();
    }

    public IList<MVHAsset> GetAssetList(PEContext peCtx)
    {
      return peCtx.MVHAssets
        .IgnoreQueryFilters()
        .ToList();
    }

    public IList<MVHFeature> GetFeatureList(PEContext peCtx)
    {
      return peCtx.MVHFeatures
        .IgnoreQueryFilters()
        .ToList();
    }

    public string GetPDTitle()
    {
      var projectName = ParameterController.GetParameter("ProjectName")?.ValueText ?? "";
      return $"{projectName}-PE-T41-L1InterfaceDetails.pdf";
    }

    public IList<UnitOfMeasure> GetUnitOfMeasureList(SMFContext smfCtx)
    {
      return smfCtx.UnitOfMeasures.ToList();
    }

    private async Task CheckAssetUniqueNameAsync(PEContext ctx, ModelStateDictionary modelState, string assetName, long? assetId = null)
    {
      MVHAsset asset = null;
      if (assetId is null)
        asset = await ctx.MVHAssets.IgnoreQueryFilters().FirstOrDefaultAsync(x => x.AssetName.ToUpper().Equals(assetName.ToUpper()));
      else
        asset = await ctx.MVHAssets.IgnoreQueryFilters().FirstOrDefaultAsync(x => x.AssetId != assetId && x.AssetName.ToUpper().Equals(assetName.ToUpper()));

      if (asset is not null)
        modelState.AddModelError("error", ResourceController.GetErrorText("AssetNameNotUnique"));
    }

    private async Task CheckAssetTypeUniqueNameAsync(PEContext ctx, ModelStateDictionary modelState, string assetName, long? assetId = null)
    {
      MVHAssetType assetType = null;
      if (assetId is null)
        assetType = await ctx.MVHAssetTypes.FirstOrDefaultAsync(x => x.AssetTypeName.ToUpper().Equals(assetName.ToUpper()));
      else
        assetType = await ctx.MVHAssetTypes.FirstOrDefaultAsync(x => x.AssetTypeId != assetId && x.AssetTypeName.ToUpper().Equals(assetName.ToUpper()));

      if (assetType is not null)
        modelState.AddModelError("error", ResourceController.GetErrorText("AssetTypeNameNotUnique"));
    }

    private async Task CheckAssetTypeUniqueCodeAsync(PEContext ctx, ModelStateDictionary modelState, string ssetCode, long? assetId = null)
    {
      MVHAssetType assetType = null;
      if (assetId is null)
        assetType = await ctx.MVHAssetTypes.FirstOrDefaultAsync(x => x.AssetTypeCode.ToUpper().Equals(ssetCode.ToUpper()));
      else
        assetType = await ctx.MVHAssetTypes.FirstOrDefaultAsync(x => x.AssetTypeId != assetId && x.AssetTypeCode.ToUpper().Equals(ssetCode.ToUpper()));

      if (assetType is not null)
        modelState.AddModelError("error", ResourceController.GetErrorText("AssetTypeCodeNotUnique"));
    }

    private async Task CheckFeatureUniqueNameAsync(PEContext ctx, ModelStateDictionary modelState, string featureName, long? featureId = null)
    {
      MVHFeature feature = null;
      if (featureId is null)
        feature = await ctx.MVHFeatures.FirstOrDefaultAsync(x => x.FeatureName.ToUpper().Equals(featureName.ToUpper()));
      else
        feature = await ctx.MVHFeatures.FirstOrDefaultAsync(x => x.FeatureId != featureId && x.FeatureName.ToUpper().Equals(featureName.ToUpper()));

      if (feature is not null)
        modelState.AddModelError("error", ResourceController.GetErrorText("FeatureNameNotUnique"));
    }

    private async Task<bool> CheckDropPossibilitiesAsync(ModelStateDictionary modelState, List<MVHAsset> assets, MVHAsset dragAsset, MVHAsset dropAsset, short dropType)
    {
      await Task.CompletedTask;

      if (dropType == 3)
      {
        if (!dropAsset.IsArea && !dropAsset.IsZone)
        {
          modelState.AddModelError("error", ResourceController.GetErrorText("Nie można do zasobu"));
          return false;
        }
      }

      return true;
    }

    private async Task UpdateAssetCode(PEContext ctx, List<MVHAsset> assets, long assetId)
    {
      var asset = assets.First(x => x.AssetId == assetId);

      if (GetRestrictedAreas().Select(x => x.Key).ToList().Contains(asset.AssetCode))
      {
        return;
      }

      var minAssetCode = TrackingArea.PLANT.Value;
      var maxAssetCode = assets.Max(x => x.AssetCode);
      var gap = 0;

      if (asset.IsZone)
      {
        gap = 1000000;
        maxAssetCode = int.MaxValue;
      }
      else if (asset.IsArea)
      {
        gap = 100000;
        var zone = await FindParentZoneAsync(assets, asset.FKParentAssetId);

        if (zone.HasValue)
        {
          minAssetCode = zone.Value;
          maxAssetCode = assets
            .OrderBy(x => x.AssetCode)
            .FirstOrDefault(x => x.IsZone && x.AssetCode > zone.Value)?.AssetCode ?? maxAssetCode;
        }
        else
          minAssetCode = assets.Where(x => x.IsZone).Max(x => x.AssetCode);
      }
      else
      {
        gap = 50;
        var area = await FindParentAreaAsync(assets, asset.FKParentAssetId) ?? await FindParentZoneAsync(assets, asset.FKParentAssetId);

        if (area.HasValue)
        {
          minAssetCode = area.Value;
          maxAssetCode = assets
            .OrderBy(x => x.AssetCode)
            .FirstOrDefault(x => (x.IsArea || x.IsZone) && x.AssetCode > area.Value)?.AssetCode ?? maxAssetCode;
        }
        else
          minAssetCode = assets.Where(x => x.IsZone).Max(x => x.AssetCode);
      }

      for (var i = minAssetCode; i < maxAssetCode; i++)
      {
        if (i % gap != 0)
          continue;

        var assetToCheck = assets.FirstOrDefault(x => x.AssetCode == i);
        if (assetToCheck is not null)
          continue;

        asset.AssetCode = i;
        break;
      }
    }

    private void UpdateFeatureCode(MVHAsset asset, int? minFeatureCode = null)
    {
      if (minFeatureCode.HasValue)
      {
        foreach (var item in asset.MVHFeatures)
        {
          item.FeatureCode = minFeatureCode.Value;
          minFeatureCode--;
        }
      }
      else
      {
        var gap = 2;
        var assetCode = asset.AssetCode;
        foreach (var item in asset.MVHFeatures)
        {
          assetCode += gap;
          item.FeatureCode = assetCode;
        }
      }
    }

    private IEnumerable<MVHAsset> GetChildrenAssets(List<MVHAsset> assets, long assetId)
    {
      return assets
        .Where(child => child.FKParentAssetId == assetId)
        .Union(assets.Where(child => child.FKParentAssetId == assetId)
        .SelectMany(parent => GetChildrenAssets(assets, parent.AssetId))
      );
    }

    private async Task<int?> FindParentZoneAsync(List<MVHAsset> assets, long? parentAssetId)
    {
      if (parentAssetId is null)
        return null;

      var asset = assets
        .First(x => x.AssetId == parentAssetId);

      if (asset.IsZone)
        return asset.AssetCode;

      return await FindParentZoneAsync(assets, asset.FKParentAssetId ?? 0);
    }

    private async Task<int?> FindParentAreaAsync(List<MVHAsset> assets, long? parentAssetId)
    {
      if (parentAssetId is null)
        return null;

      var asset = assets
        .First(x => x.AssetId == parentAssetId);

      if (asset.IsArea)
        return asset.AssetCode;

      return await FindParentAreaAsync(assets, asset.FKParentAssetId ?? 0);
    }

    private async Task UpdateOrderSequence(PEContext ctx, List<long> orderSeq, List<MVHAsset> assets, long? assetId)
    {
      var assetsToRemove = new List<long>();
      if (assetId.HasValue && assets.Any(x => x.FKParentAssetId == assetId))
      {
        assetsToRemove = GetChildrenAssets(assets, assetId.Value).ToList().Select(x => x.AssetId).ToList();
      }

      DataTable assetIds = GenerateDataTable(orderSeq, assetsToRemove, assetId);

      SqlParameter[] parameters = new SqlParameter[] {
                        new SqlParameter() {
                            ParameterName = "@AssetIds",
                            TypeName = "dbo.AssetId_List",
                            IsNullable = false,
                            Direction = ParameterDirection.Input,
                            Value = assetIds
                        }};
      await ctx.ExecuteSPRenumberAssets(parameters);
    }

    private DataTable GenerateDataTable(List<long> orderSeq, List<long> assetsToRemove, long? assetId)
    {
      DataTable result = new DataTable();
      result.Columns.Add("AssetId");

      if (assetsToRemove.Any())
      {
        assetsToRemove = assetsToRemove.OrderBy(x => orderSeq.IndexOf(x)).ToList();

        foreach (var assetToRemove in assetsToRemove)
        {
          orderSeq.Remove(assetToRemove);
        }

        foreach (var item in orderSeq)
        {
          result.Rows.Add(item);

          if (item == assetId)
          {
            foreach (var element in assetsToRemove)
            {
              result.Rows.Add(element);
            }
          }
        }
      }
      else
      {
        foreach (var asset in orderSeq)
          result.Rows.Add(asset);
      }

      return result;
    }

    private List<KeyValuePair<int, string>> GetRestrictedAreas()
    {
      var result = new List<KeyValuePair<int, string>>();

      foreach (FieldInfo propertyItem in typeof(TrackingArea).GetFields(BindingFlags.Public |
        BindingFlags.Static))
      {
        dynamic item = propertyItem.GetValue(null);

        result.Add(new KeyValuePair<int, string>((int)item.Value, item.Name));
      }

      return result;
    }

    private async Task UpdateEnumsAsync(List<MVHAsset> assets)
    {
      await using var smfCtx = new SMFContext();
      var enums = await smfCtx.EnumValues
        .Where(x => x.FkEnumNameId == 121 && x.IsCustom == true)
        .ToListAsync();

      foreach (var item in enums)
      {
        var asset = assets.FirstOrDefault(x => x.AssetName.Equals(item.Keyword));
        if (asset is null)
          continue;

        if (asset.AssetCode != item.Value)
          item.Value = asset.AssetCode;
      }

      await smfCtx.SaveChangesAsync();
    }

    private async Task RemoveRelations(PEContext ctx, List<long> featureIds, List<long> assetIds)
    {
      await Task.CompletedTask;

      if (assetIds.Any())
      {
        ctx.EVTEvents.RemoveRange(ctx.EVTEvents.Where(x => x.FKAssetId.HasValue && assetIds.Contains(x.FKAssetId.Value)));
        ctx.PRMMaterialSteps.RemoveRange(ctx.PRMMaterialSteps.Where(x => assetIds.Contains(x.FKAssetId)));
        ctx.MVHAssetsLocations.RemoveRange(ctx.MVHAssetsLocations.Where(x => assetIds.Contains(x.FKAssetId)));
        ctx.TRKRawMaterialsSteps.RemoveRange(ctx.TRKRawMaterialsSteps.Where(x => assetIds.Contains(x.FKAssetId)));
        ctx.MVHAssetLayouts.RemoveRange(ctx.MVHAssetLayouts.Where(x => assetIds.Contains(x.FKNextAssetId) || assetIds.Contains(x.FKPrevAssetId)));
        ctx.ZPCZebraPrinters.RemoveRange(ctx.ZPCZebraPrinters.Where(x => x.FKAssetId.HasValue && assetIds.Contains(x.FKAssetId.Value)));
      }
      if (featureIds.Any())
      {
        ctx.MVHMeasurements.RemoveRange(ctx.MVHMeasurements.Where(x => featureIds.Contains(x.FKFeatureId)));
        ctx.TRKTrackingInstructions.RemoveRange(ctx.TRKTrackingInstructions.Where(x => featureIds.Contains(x.FKFeatureId)));
        ctx.EVTTriggersFeatures.RemoveRange(ctx.EVTTriggersFeatures.Where(x => featureIds.Contains(x.FKFeatureId)));
      }
    }

    private async Task<MVHAssetTemplate> GetAssetTemplateAsync(PEContext ctx, long assetTemplateId)
    {
      return await ctx.MVHAssetTemplates.FirstAsync(x => x.AssetTemplateId == assetTemplateId);
    }

    private async Task<List<MVHFeatureTemplate>> GetFeatureTemplatesByAssetTemplateAsync(PEContext ctx, long assetTemplateId)
    {
      return await ctx.MVHAssetFeatureTemplates
        .Include(x => x.FKFeatureTemplate)
        .Where(x => x.FKAssetTemplateId == assetTemplateId)
        .Select(x => x.FKFeatureTemplate)
        .ToListAsync();
    }

    private async Task<List<MVHAsset>> GetAssetsAsync(PEContext ctx, bool includeFeatures = false)
    {
      if (includeFeatures)
        return await ctx.MVHAssets
          .IgnoreQueryFilters()
          .Include(x => x.MVHFeatures)
          .ToListAsync();

      return await ctx.MVHAssets
        .IgnoreQueryFilters()
        .ToListAsync();
    }

    private async Task<MVHAsset> GetAssetAsync(PEContext ctx, long assetId, bool includeFeatures = false)
    {
      if (includeFeatures)
        return await ctx.MVHAssets
          .IgnoreQueryFilters()
          .Include(x => x.MVHFeatures)
          .FirstAsync(x => x.AssetId == assetId);

      return await ctx.MVHAssets
        .IgnoreQueryFilters()
        .FirstAsync(x => x.AssetId == assetId);
    }

    private async Task<MVHFeature> GetFeatureAsync(PEContext ctx, long featureId)
    {
      return await ctx.MVHFeatures
        .IgnoreQueryFilters()
        .FirstAsync(x => x.FeatureId == featureId);
    }

    private async Task<List<MVHAsset>> GetAssetsByAssetTypeAsync(PEContext ctx, long assetTypeId, bool includeFeatures = false)
    {
      if (includeFeatures)
        return await ctx.MVHAssets
          .IgnoreQueryFilters()
          .Include(x => x.MVHFeatures)
          .Where(x => x.FKAssetTypeId == assetTypeId)
          .ToListAsync();

      return await ctx.MVHAssets
        .IgnoreQueryFilters()
        .Where(x => x.FKAssetTypeId == assetTypeId)
        .ToListAsync();
    }

    private async Task<List<MVHFeature>> GetFeaturesAsync(PEContext ctx, long? assetId = null)
    {
      if (assetId is not null)
      {
        return await ctx.MVHFeatures
          .IgnoreQueryFilters()
          .Where(x => x.FKAssetId == assetId.Value)
          .ToListAsync();
      }

      return await ctx.MVHFeatures
        .IgnoreQueryFilters()
        .ToListAsync();
    }

    private int GetLowestNumber(IEnumerable<int> data)
    {
      if (data is null || !data.Any())
        return -1;

      var result = data.Min() - 1;

      return result >= 0 ? -1 : result;
    }

    private async Task CreateFeaturesForAssetFromTemplatesAsync(PEContext ctx, List<MVHFeatureTemplate> featureTemplates, MVHAsset asset)
    {
      if (featureTemplates is not null && featureTemplates.Any())
      {
        var lowestFeatureCode = GetLowestNumber((await GetFeaturesAsync(ctx)).Select(x => x.FeatureCode));

        var parentFeatureTemplate = featureTemplates
          .FirstOrDefault(x => x.FeatureTemplateName.ToUpper().Contains("OCC") || x.FeatureTemplateName.ToUpper().Contains("NDR"));

        if (parentFeatureTemplate is not null)
          featureTemplates = featureTemplates
            .OrderBy(x => x.FeatureTemplateId != parentFeatureTemplate.FeatureTemplateId)
            .ToList();

        MVHFeature parentFeature = null;

        foreach (var item in featureTemplates)
        {
          var newFeature = new MVHFeature
          {
            FKAsset = asset,
            FKUnitOfMeasureId = item.FKUnitOfMeasureId,
            FKExtUnitOfMeasureId = item.FKExtUnitOfMeasureId,
            FKDataTypeId = item.FKDataTypeId,
            FKParentFeature = parentFeature,
            FeatureCode = lowestFeatureCode,
            FeatureName = $"{asset.AssetName}.{(item.EnumAggregationStrategy == AggregationStrategy.Logical ? "STAT" : "MEAS")}.{item.FeatureTemplateName}",
            FeatureDescription = item.FeatureTemplateDescription,
            IsSampledFeature = false,
            IsConsumptionPoint = false,
            IsMaterialRelated = true,
            IsLengthRelated = false,
            IsQETrigger = false,
            IsDigital = item.EnumAggregationStrategy == AggregationStrategy.Logical,
            IsActive = asset.IsActive,
            IsOnHMI = false,
            SampleOffsetTime = null,
            ConsumptionAggregationTime = null,
            MinValue = null,
            MaxValue = null,
            RetentionFactor = null,
            EnumFeatureType = item.EnumFeatureType,
            EnumCommChannelType = item.EnumCommChannelType,
            EnumAggregationStrategy = item.EnumAggregationStrategy,
            CommAttr1 = item.TemplateCommAttr1,
            CommAttr2 = $"ns=3;s=\"AdhDataIn\".\"Data\".\"{asset.AssetName}\".\"{(item.EnumAggregationStrategy == AggregationStrategy.Logical ? "STAT" : "MEAS")}\".\"{item.FeatureTemplateName}\"",
            CommAttr3 = item.TemplateCommAttr3,
            EnumFeatureProvider = FeatureProvider.L1,
            EnumTagValidationResult = TagValidationResult.Undefined
          };

          await ctx.MVHFeatures.AddAsync(newFeature);

          if (parentFeatureTemplate is not null && parentFeature is null)
            parentFeature = newFeature;
          lowestFeatureCode--;
        }
      }
    }

    private async Task CreateFeaturesForAssetAsync(PEContext ctx, MVHAsset asset, long templateAssetId, string previousAssetName)
    {
      var features = await GetFeaturesAsync(ctx);
      var lowestFeatureCode = GetLowestNumber(features.Select(x => x.FeatureCode));
      features = features.Where(x => x.FKAssetId == templateAssetId).ToList();

      if (features is not null && features.Any())
      {
        var templateFeature = features
          .FirstOrDefault(x => x.FeatureName.ToUpper().Contains("OCC") || x.FeatureName.ToUpper().Contains("NDR"));

        if (templateFeature is not null)
          features = features
            .OrderBy(x => x.FeatureId != templateFeature.FeatureId)
            .ToList();

        MVHFeature parentFeature = null;

        foreach (var item in features)
        {
          var newFeature = new MVHFeature
          {
            FKAsset = asset,
            FKUnitOfMeasureId = item.FKUnitOfMeasureId,
            FKExtUnitOfMeasureId = item.FKExtUnitOfMeasureId,
            FKDataTypeId = item.FKDataTypeId,
            FKParentFeature = parentFeature,
            FeatureCode = lowestFeatureCode,
            FeatureName = item.FeatureName.Replace(previousAssetName, asset.AssetName),
            FeatureDescription = item.FeatureDescription,
            IsSampledFeature = false,
            IsConsumptionPoint = false,
            IsMaterialRelated = true,
            IsLengthRelated = false,
            IsQETrigger = false,
            IsDigital = item.EnumAggregationStrategy == AggregationStrategy.Logical,
            IsActive = item.IsActive,
            IsOnHMI = asset.IsVisibleOnMVH,
            IsTrackingPoint = item.EnumFeatureType == FeatureType.TrackingOccupied,
            IsMeasurementPoint = item.EnumAggregationStrategy == AggregationStrategy.FloatingPoint,
            SampleOffsetTime = null,
            ConsumptionAggregationTime = null,
            MinValue = null,
            MaxValue = null,
            RetentionFactor = null,
            EnumFeatureType = item.EnumFeatureType,
            EnumCommChannelType = item.EnumCommChannelType,
            EnumAggregationStrategy = item.EnumAggregationStrategy,
            CommAttr1 = item.CommAttr1,
            CommAttr2 = item.CommAttr2?.Replace(previousAssetName, asset.AssetName),
            CommAttr3 = item.CommAttr3,
            EnumFeatureProvider = FeatureProvider.L1,
            EnumTagValidationResult = TagValidationResult.Undefined
          };

          await ctx.MVHFeatures.AddAsync(newFeature);

          if (templateFeature is not null && parentFeature is null)
            parentFeature = newFeature;
          lowestFeatureCode--;
        }
      }
    }

    private async Task UpdateCustomEnumsAsync(MVHAsset asset)
    {
      await using var smfCtx = new SMFContext();
      await smfCtx.EnumValues.AddAsync(new EnumValue
      {
        FkEnumNameId = 121,
        Keyword = asset.AssetName,
        Value = asset.AssetCode,
        IsCustom = true
      });

      await smfCtx.SaveChangesAsync();
    }
  }

  public class CustomOpcClient : SmfOpcClient
  {
    public CustomOpcClient(string opcServerAddress) : base(opcServerAddress)
    {
    }

    public OpcClient OpcClientObject => OpcClient;
  }
}
