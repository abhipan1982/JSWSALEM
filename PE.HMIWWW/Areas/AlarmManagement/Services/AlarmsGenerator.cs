using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using SMF.DbEntity.Models;

namespace PE.HMIWWW.Areas.AlarmManagement.Services
{
  public class AlarmsGenerator
  {
    private readonly SMFContext _smfCtx;

    public AlarmsGenerator(SMFContext smfCtx)
    {
      _smfCtx = smfCtx;
    }

    public async Task<string> GenerateAsync(bool standard)
    {
      var alarmDefinitions = await _smfCtx.AlarmDefinitions
        .Include(x => x.FKAlarmCategory)
        .Include(x => x.AlarmMessages.Where(m => m.FKLanguage.IsDefault))
        .Include(x => x.AlarmDefinitionParams)
        .Where(x => x.FKAlarmCategory.CategoryCode == "Process" && x.IsStandard == standard)
        .OrderBy(x => x.DefinitionCode)
        .ToListAsync();

      var className = standard ? "ModuleAlarmDefsBase" : "ModuleAlarmDefs";
      var @namespace = standard ? "PE.Common" : "PE.Models.AlarmDefinitions";
      var result = GenerateAlarmDefs(alarmDefinitions, @namespace, className);
      return result;

    }

    private string GenerateAlarmDefs(IEnumerable<AlarmDefinition> alarmDefinitionsData, string @namespace, string className)
    {
      var sb = new StringBuilder();

      sb.AppendLine(@$"// THIS CODE WAS GENERATED BY ALARMCREATOR.v3");
      sb.AppendLine(@$"// DO NOT MODIFY IT MANUALLY - IT SHOULD BE REGENERATED");
      sb.AppendLine();
      sb.AppendLine($"namespace {@namespace}");
      sb.AppendLine($"{{");
      sb.AppendLine($"{I(1)}public static class {className}");
      sb.AppendLine($"{I(1)}{{");

      foreach (var alarmDefinition in alarmDefinitionsData)
      {
        sb.AppendLine($"{I(2)}/// <summary>");
        sb.AppendLine($"{I(2)}/// Alarm definition for AlarmId: {alarmDefinition.AlarmDefinitionId}");

        var message = alarmDefinition.AlarmMessages.First();

        sb.AppendLine($"{I(2)}/// FORMAT: {message.MessageText}");

        if (alarmDefinition.AlarmDefinitionParams.Count > 0)
        {
          sb.Append($"{I(2)}/// PARAMS: ");
          sb.AppendLine(string.Join(", ", alarmDefinition.AlarmDefinitionParams.OrderBy(dv => dv.ParamKey).Select(x => $"@{x.ParamKey}: {x.ParamName}")));
        }

        sb.AppendLine($"{I(2)}/// </summary>");
        sb.AppendLine($"{I(2)}public const string AlarmCode_{DescriptionFormatter(alarmDefinition.DefinitionDescription)} = \"{alarmDefinition.DefinitionCode}\";");
        sb.AppendLine();
      }

      sb.AppendLine($"{I(1)}}}");
      sb.AppendLine($"}}");

      return sb.ToString();
    }

    /// <summary>
    /// Print indentation
    /// </summary>
    /// <param name="level">Nesting level</param>
    private static string I(int level)
    {
      return new string(' ', level * 2);
    }

    private string DescriptionFormatter(string input)
    {
      string result = "";

      // remove whitespaces and split to array for first letter capitalization
      string[] tempArray = input.Split(' ');

      // capitalize first word letters
      for (int i = 0; i < tempArray.Length; i++)
      {
        char[] tmpChars = tempArray[i].ToCharArray();
        tmpChars[0] = tmpChars[0].ToString().ToUpper().ToCharArray()[0];
        tempArray[i] = new string(tmpChars);
      }

      // join back to one string (without whitespaces)
      for (int i = 0; i < tempArray.Length; i++)
      {
        result += tempArray[i];
      }

      // remove special characters, allow only defined characters (whitelist)
      StringBuilder removedSpecialCharactersBuilder = new StringBuilder();
      foreach (char c in result)
      {
        if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
        {
          removedSpecialCharactersBuilder.Append(c);
        }
      }

      result = removedSpecialCharactersBuilder.ToString();
      return result;
    }
  }
}
