using System;
using System.Collections.Generic;
using System.Linq;
using PE.BaseModels.DataContracts.Internal.L1A;
using PE.Helpers;
using PE.TRK.Base.Models.TrackingComponents.MaterialInfos.Abstract;
using PE.TRK.Base.Models.TrackingComponents.MaterialInfos.Concrete;
using PE.TRK.Base.Providers.Abstract;
using SMF.Core.Notification;

namespace PE.TRK.Base.Models.TrackingEntities.Abstract
{
  [Serializable]
  public abstract class CtrMaterialBase
  {
    protected readonly ITrackingStorageProviderBase StorageProvider;
    protected readonly ITrackingEventStorageProviderBase EventStorageProvider;

    /// <summary>
    ///   GUID - autogenerated - for identity purposes
    /// </summary>
    public string Id { get; private set; } = Guid.NewGuid().ToString();

    public DateTime CreatedDate { get; private set; } = DateTime.Now;

    /// <summary>
    ///   Material Start date - initialized when first signal came
    /// </summary>
    public DateTime? StartDate { get; private set; }

    /// <summary>
    ///   List of line areas
    /// </summary>
    public List<Step> Steps { get; private set; } = new List<Step>();

    /// <summary>
    ///   Metadata for material
    /// </summary>
    public MaterialInfoBase MaterialInfo { get; private set; } = new MaterialInfo(0);

    public List<TrackingPoint> TrackingPoints { get; private set; } = new List<TrackingPoint>();


    public CtrMaterialBase(ITrackingStorageProviderBase storageProvider,
      ITrackingEventStorageProviderBase eventStorageProvider)
    {
      StorageProvider = storageProvider;
      EventStorageProvider = eventStorageProvider;
    }


    /// <summary>
    ///   Setting material info
    /// </summary>
    /// <param name="materialInfo"></param>
    public void SetMaterialInfo(MaterialInfoBase materialInfo)
    {
      MaterialInfo = materialInfo;
    }

    public void SetStartDate(DateTime date)
    {
      StartDate = date;
    }

    /// <summary>
    ///   Adding new area to the line
    /// </summary>
    /// <param name="step"></param>
    public void AddStep(Step step)
    {
      Steps.Add(step);
    }

    public void AddTrackingPoints(List<TrackingPoint> trackingPoints)
    {
      TrackingPoints.AddRange(trackingPoints);
    }

    public bool StepExist(int trackingAreaAssetCode)
    {
      return Steps.Any(s => s.AssetCode == trackingAreaAssetCode);
    }

    public void ProcessSingleTrackingPoint(int trackingPointAssetCode, bool placeOccupied, DateTime operationDate)
    {
      int maxPointsForFix = 2;
      List<TrackingPoint> trackingPointsToCheck = new List<TrackingPoint>();

      TrackingPoint currentTrackingPoint = TrackingPoints.First(x => x.AssetCode == trackingPointAssetCode);
      Step currentStep = Steps.First(x => x.AssetCode == currentTrackingPoint.StepAssetCode);
      if (trackingPointAssetCode > StorageProvider.MaxAssetCodeForNonInitializedMaterialBeingUsed && MaterialInfo.MaterialId == 0)
      {
        RemoveMaterial();
      }
      else
      {
        if (placeOccupied)
        {
          if (currentTrackingPoint.HeadReceived)
          {
            NotificationController.Warn($"ProcessSingleTrackingPoint - HeadEnter - Operation already done for TP: {trackingPointAssetCode}");
            return;
          }

          currentTrackingPoint.ChangeHeadReceived(true, operationDate, MaterialInfo.MaterialId);

          // Get elements to check from the current step

          trackingPointsToCheck.AddRange(TrackingPoints
            .Where(x => x.StepAssetCode == currentTrackingPoint.StepAssetCode &&
            x.Sequence < currentTrackingPoint.Sequence)
            .OrderByDescending(x => x.Sequence)
            .Take(maxPointsForFix)
            .ToList());

          if (trackingPointsToCheck.Count < maxPointsForFix && currentStep.PreviousSteps.Any())
          {
            var previousStepAssetCodes = currentStep.PreviousSteps.Select(x => x.AssetCode).ToList();

            var stepToCheck = Steps
              .FirstOrDefault(x => previousStepAssetCodes.Contains(x.AssetCode) &&
              x.HeadReceivedFirstDate.HasValue);

            if (stepToCheck != null)
            {
              trackingPointsToCheck.AddRange(TrackingPoints
              .Where(x => x.StepAssetCode == stepToCheck.AssetCode &&
                x.Sequence < currentTrackingPoint.Sequence)
              .OrderByDescending(x => x.Sequence)
              .Take(maxPointsForFix - trackingPointsToCheck.Count)
              .ToList());
            }
          }

          foreach (TrackingPoint trackingPointToCheck in trackingPointsToCheck)
          {
            if (!trackingPointToCheck.HeadReceived)
            {
              trackingPointToCheck.ChangeHeadReceived(true, operationDate, MaterialInfo.MaterialId);

              var previousStep = Steps.First(x => x.AssetCode == trackingPointToCheck.StepAssetCode);

              if (!previousStep.HeadReceivedFirstDate.HasValue && MaterialInfo.MaterialId > 0)
              {
                previousStep.SetHeadReceivedFirstDate(operationDate, MaterialInfo.MaterialId);
              }
            }
            else
            {
              break;
            }
          }

          if (!currentStep.HeadReceivedFirstDate.HasValue && MaterialInfo.MaterialId > 0)
          {
            currentStep.SetHeadReceivedFirstDate(operationDate, MaterialInfo.MaterialId);
          }

          if (MaterialInfo.MaterialId > 0 && !MaterialInfo.IsDummy)
          {
            StorageProvider.CtrGreyArea.SetCTRAssetCodeForMaterialId(MaterialInfo.MaterialId, currentStep.AssetCode);
          }
        }
        else
        {
          if (currentTrackingPoint.TailReceived)
          {
            NotificationController.Warn($"ProcessSingleTrackingPoint - TailReceived - Operation already done for TP: {trackingPointAssetCode}");
            return;
          }

          currentTrackingPoint.ChangeTailReceived(true, operationDate, MaterialInfo.MaterialId);

          #region Fix only 1 previous not occupied
          var trackingPointToFix = TrackingPoints
              .Where(x => x.StepAssetCode == currentTrackingPoint.StepAssetCode &&
              x.Sequence < currentTrackingPoint.Sequence)
              .OrderByDescending(x => x.Sequence)
              .FirstOrDefault();

          if (trackingPointToFix == null && currentStep.PreviousSteps.Any())
          {
            var stepToCheck = Steps
              .FirstOrDefault(x => currentStep.PreviousSteps.Select(x => x.AssetCode).Contains(x.AssetCode) &&
              x.HeadReceivedFirstDate.HasValue);

            if (stepToCheck != null)
            {
              trackingPointToFix = TrackingPoints
                .Where(x => x.StepAssetCode == stepToCheck.AssetCode &&
                  x.Sequence < currentTrackingPoint.Sequence)
                .OrderByDescending(x => x.Sequence)
                .FirstOrDefault();
            }
          }

          if (trackingPointToFix != null)
          {
            if (!trackingPointToFix.TailReceived)
            {
              trackingPointToFix.ChangeTailReceived(true, operationDate, MaterialInfo.MaterialId);

              if (trackingPointToFix.StepAssetCode != currentStep.AssetCode)
              {
                var previousStep = Steps.First(x => x.AssetCode == trackingPointToFix.StepAssetCode);

                bool processedPreviousStep = !TrackingPoints
                  .Where(x => x.StepAssetCode == previousStep.AssetCode)
                  .Any(x => !x.HeadReceived || !x.TailReceived);

                if (processedPreviousStep && !previousStep.TailReceivedLastDate.HasValue)
                {
                  previousStep.SetTailReceivedLastDate(operationDate, MaterialInfo.MaterialId);
                  ProcessAreaMeasurements(previousStep);
                }
              }
            }
          }
          #endregion

          bool processedStep = !TrackingPoints
            .Where(x => x.StepAssetCode == currentStep.AssetCode)
            .Any(x => !x.HeadReceived || !x.TailReceived);

          NotificationController.Debug($"[NOT-OCC] ProcessedStep: {currentStep.AssetCode}, isProcessed: {processedStep}, TrackingPoint: {trackingPointAssetCode}, CurrentStepReceivedLastDate: {currentStep.TailReceivedLastDate}");

          if (processedStep && !currentStep.TailReceivedLastDate.HasValue)
          {
            currentStep.SetTailReceivedLastDate(operationDate, MaterialInfo.MaterialId);
            ProcessAreaMeasurements(currentStep);
          }

          _ = ShouldBeRemoved(out TrackingPointBase lastTrackingPoint, out bool isFinished);

          if (isFinished)
            RemoveMaterial();
        }
      }
    }

    protected virtual void ProcessAreaMeasurements(Step currentStep)
    {
      TaskHelper.FireAndForget(() =>
      {
        if (MaterialInfo?.MaterialId > 0)
        {
          EventStorageProvider.AggregatedMeasurementsToBeProcessed
          .Enqueue(new DcAggregatedMeasurementRequest()
          {
            MaterialId = MaterialInfo.MaterialId,
            AreaAssetCode = currentStep.AssetCode,
            MeasurementListToProcess = TrackingPoints
              .Where(x => x.StepAssetCode == currentStep.AssetCode)
              .Select(x =>
                new DcMeasurementRequest(x.OccupiedFeatureCode, x.HeadReceivedDate.Value, x.TailReceivedDate.Value))
              .ToList()
          });
        }
        else
        {
          NotificationController.Warn($"No materialId yet assigned for processedStep {currentStep.AssetCode}");
        }
      });
    }

    public bool ShouldBeRemoved(out TrackingPointBase lastTrackingPoint, out bool isFinished)
    {
      var stepsShouldBeProcessed = Steps.Where(x => x.HeadReceivedFirstDate.HasValue).Select(x => x.AssetCode)
            .ToList();
      var trackingPointsToBeProcessed = TrackingPoints.Where(x => stepsShouldBeProcessed.Contains(x.StepAssetCode))
        .ToList();

      isFinished = false;
      lastTrackingPoint = trackingPointsToBeProcessed.OrderByDescending(x => x.Sequence).FirstOrDefault(x => x.HeadReceived);

      if (trackingPointsToBeProcessed
        .All(x => x.HeadReceived == x.TailReceived) && trackingPointsToBeProcessed.Any(x => x.HeadReceived))
      {
        // in case if wrong material - it will be removed with the next material
        if (!trackingPointsToBeProcessed.Any(x => !x.HeadReceived))
          isFinished = true;

        return true;
      }

      return false;
    }

    public void ProcessInManualMode(DateTime operationDate)
    {
      FixTailReceivedWithoutHeadEnter(operationDate);
      MarkAllHeadEnteredPointsAsTailReceived(operationDate);

      RemoveMaterial();
    }

    public virtual void FixTailReceivedWithoutHeadEnter(DateTime operationDate)
    {
      foreach (TrackingPoint point in TrackingPoints)
      {
        if (!point.HeadReceived && point.TailReceived)
          point.ChangeTailReceived(false, null, MaterialInfo.MaterialId);
      }
    }

    public virtual void MarkAllHeadEnteredPointsAsTailReceived(DateTime operationDate)
    {
      var stepsToBeProcessed = new List<Step>();

      foreach (TrackingPoint point in TrackingPoints)
      {
        if (point.HeadReceived)
        {
          point.ChangeTailReceived(true, operationDate, MaterialInfo.MaterialId);
          var step = Steps.First(x => x.AssetCode == point.StepAssetCode);

          if (!stepsToBeProcessed.Contains(step))
          {
            step.SetTailReceivedLastDate(operationDate, MaterialInfo.MaterialId);

            stepsToBeProcessed.Add(step);
          }
        }
      }

      foreach (var step in stepsToBeProcessed)
      {
        ProcessAreaMeasurements(step);
      }
    }

    public virtual void RemoveMaterial(int retryCount = 0)
    {
      if (retryCount <= 3)
      {
        try
        {
          StorageProvider.Materials.TryRemove(this.Id, out CtrMaterialBase material);
          StorageProvider.LastRemovedMaterial = material;
        }
        catch (Exception ex)
        {
          NotificationController.LogException(ex);
          RemoveMaterial(retryCount + 1);
        }
      }
    }


    public void MarkAllPointsAsHeadReceived(DateTime operationDate)
    {
      foreach (TrackingPoint trackingPoint in TrackingPoints.Where(x => !x.HeadReceived))
      {
        trackingPoint.ChangeHeadReceived(true, operationDate, MaterialInfo.MaterialId);
      }

      foreach (Step step in Steps.Where(x => !x.HeadReceivedFirstDate.HasValue))
      {
        step.SetHeadReceivedFirstDate(operationDate, MaterialInfo.MaterialId);
      }
    }

    public void MarkAllPointsAsTailReceived(DateTime operationDate)
    {
      foreach (TrackingPoint trackingPoint in TrackingPoints.Where(x => !x.TailReceived))
      {
        trackingPoint.ChangeTailReceived(true, operationDate, MaterialInfo.MaterialId);
      }

      foreach (Step step in Steps.Where(x => !x.TailReceivedLastDate.HasValue))
      {
        step.SetTailReceivedLastDate(operationDate, MaterialInfo.MaterialId);
      }
    }
  }
}
