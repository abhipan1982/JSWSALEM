

// 
// This code was generated by EnumClassesGenerator tool. Any changes made manually will be lost
// the next time this code is regenerated.
// szymon.franczyk@primetals.com
// 
// Generated at: 03/06/2023 11:51:35
//
using System;
using SMF.DbEntity.EnumClasses;
namespace PE.BaseDbEntity.EnumClasses
//[SF] Connection string: Server=148.56.68.36;Database=PE_Developer;Trusted_Connection=false;User Id=sa;Password=Primetals.;

{
    [Serializable]
    public class TelegramIds : GenericEnumType<short>
    {
        public static readonly TelegramIds Undefined = new TelegramIds(0, "Undefined");
        public static readonly TelegramIds TelID_BilletLoadedOnGrill = new TelegramIds(1001, "TelID_BilletLoadedOnGrill");
        public static readonly TelegramIds TelID_BilletUnloadedFromGrill = new TelegramIds(1002, "TelID_BilletUnloadedFromGrill");
        public static readonly TelegramIds TelID_FurnaceCharged = new TelegramIds(1003, "TelID_FurnaceCharged");
        public static readonly TelegramIds TelID_FurnaceUncharged = new TelegramIds(1004, "TelID_FurnaceUncharged");
        public static readonly TelegramIds TelID_FurnaceDischarged = new TelegramIds(1005, "TelID_FurnaceDischarged");
        public static readonly TelegramIds TelID_FurnaceDischargeCmd = new TelegramIds(1006, "TelID_FurnaceDischargeCmd");
        public static readonly TelegramIds TelID_FurnaceUndischarged = new TelegramIds(1007, "TelID_FurnaceUndischarged");
        public static readonly TelegramIds TelID_FurnaceChargeCmd = new TelegramIds(1008, "TelID_FurnaceChargeCmd");
        public static readonly TelegramIds TelID_ChargingWeight = new TelegramIds(1009, "TelID_ChargingWeight");
        public static readonly TelegramIds TelID_FurnaceMap = new TelegramIds(1010, "TelID_FurnaceMap");
        public static readonly TelegramIds TelID_FurnaceMapCyclic = new TelegramIds(1011, "TelID_FurnaceMapCyclic");
        public static readonly TelegramIds TelID_FCECharge = new TelegramIds(1012, "TelID_FCECharge");
        public static readonly TelegramIds TelID_FCEWeight = new TelegramIds(1013, "TelID_FCEWeight");
        public static readonly TelegramIds TelID_FCELength = new TelegramIds(1014, "TelID_FCELength");
        public static readonly TelegramIds TelID_FurnaceDischarging = new TelegramIds(1113, "TelID_FurnaceDischarging");
        public static readonly TelegramIds TelID_AdapterStatus = new TelegramIds(2000, "TelID_AdapterStatus");
        public static readonly TelegramIds TelId_L1TCPStatus = new TelegramIds(2001, "TelId_L1TCPStatus");
        public static readonly TelegramIds TelID_L1OPCStatus = new TelegramIds(2002, "TelID_L1OPCStatus");
        public static readonly TelegramIds TelID_ExtDBStatus = new TelegramIds(2003, "TelID_ExtDBStatus");
        public static readonly TelegramIds TelId_TrackingStatus = new TelegramIds(2004, "TelId_TrackingStatus");
        public static readonly TelegramIds TelID_FurnaceReport = new TelegramIds(3001, "TelID_FurnaceReport");
        public static readonly TelegramIds TelID_EmptyTelegramForTCP = new TelegramIds(5000, "TelID_EmptyTelegramForTCP");
        public static readonly TelegramIds TelID_ExtTransferTableData = new TelegramIds(5001, "TelID_ExtTransferTableData");
        public static readonly TelegramIds TelID_ExtWorkOrderTransferTableData = new TelegramIds(5003, "TelID_ExtWorkOrderTransferTableData");
        public static readonly TelegramIds TelID_RetExtTransferTableData = new TelegramIds(6001, "TelID_RetExtTransferTableData");
        public static readonly TelegramIds TelID_ExtOutputTransferOrderTableData = new TelegramIds(6002, "TelID_ExtOutputTransferOrderTableData");
        public static readonly TelegramIds TelID_ExtOutputTransferProductTableData = new TelegramIds(6003, "TelID_ExtOutputTransferProductTableData");
        public static readonly TelegramIds TelID_ExtUniversalTelegram = new TelegramIds(7001, "TelID_ExtUniversalTelegram");

        protected static Func<short, TelegramIds> GetCustom;
        protected TelegramIds(short value, string name) : base(value, name)
        {
        }

        protected static TelegramIds GetInstance(short value, string name) => new TelegramIds(value, name);
        public override string ToString() => $"TelegramIds({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TelegramIds obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TelegramIds(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TelegramIds other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TelegramIds obj1, TelegramIds obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TelegramIds obj1, TelegramIds obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TelegramIds obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TelegramIds obj2) => !(obj1 == obj2);

        public static bool operator ==(TelegramIds obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TelegramIds obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TelegramIds GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == TelID_BilletLoadedOnGrill.Value:
                return TelID_BilletLoadedOnGrill;
                case var value when value == TelID_BilletUnloadedFromGrill.Value:
                return TelID_BilletUnloadedFromGrill;
                case var value when value == TelID_FurnaceCharged.Value:
                return TelID_FurnaceCharged;
                case var value when value == TelID_FurnaceUncharged.Value:
                return TelID_FurnaceUncharged;
                case var value when value == TelID_FurnaceDischarged.Value:
                return TelID_FurnaceDischarged;
                case var value when value == TelID_FurnaceDischargeCmd.Value:
                return TelID_FurnaceDischargeCmd;
                case var value when value == TelID_FurnaceUndischarged.Value:
                return TelID_FurnaceUndischarged;
                case var value when value == TelID_FurnaceChargeCmd.Value:
                return TelID_FurnaceChargeCmd;
                case var value when value == TelID_ChargingWeight.Value:
                return TelID_ChargingWeight;
                case var value when value == TelID_FurnaceMap.Value:
                return TelID_FurnaceMap;
                case var value when value == TelID_FurnaceMapCyclic.Value:
                return TelID_FurnaceMapCyclic;
                case var value when value == TelID_FCECharge.Value:
                return TelID_FCECharge;
                case var value when value == TelID_FCEWeight.Value:
                return TelID_FCEWeight;
                case var value when value == TelID_FCELength.Value:
                return TelID_FCELength;
                case var value when value == TelID_FurnaceDischarging.Value:
                return TelID_FurnaceDischarging;
                case var value when value == TelID_AdapterStatus.Value:
                return TelID_AdapterStatus;
                case var value when value == TelId_L1TCPStatus.Value:
                return TelId_L1TCPStatus;
                case var value when value == TelID_L1OPCStatus.Value:
                return TelID_L1OPCStatus;
                case var value when value == TelID_ExtDBStatus.Value:
                return TelID_ExtDBStatus;
                case var value when value == TelId_TrackingStatus.Value:
                return TelId_TrackingStatus;
                case var value when value == TelID_FurnaceReport.Value:
                return TelID_FurnaceReport;
                case var value when value == TelID_EmptyTelegramForTCP.Value:
                return TelID_EmptyTelegramForTCP;
                case var value when value == TelID_ExtTransferTableData.Value:
                return TelID_ExtTransferTableData;
                case var value when value == TelID_ExtWorkOrderTransferTableData.Value:
                return TelID_ExtWorkOrderTransferTableData;
                case var value when value == TelID_RetExtTransferTableData.Value:
                return TelID_RetExtTransferTableData;
                case var value when value == TelID_ExtOutputTransferOrderTableData.Value:
                return TelID_ExtOutputTransferOrderTableData;
                case var value when value == TelID_ExtOutputTransferProductTableData.Value:
                return TelID_ExtOutputTransferProductTableData;
                case var value when value == TelID_ExtUniversalTelegram.Value:
                return TelID_ExtUniversalTelegram;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class YesNo : GenericEnumType<short>
    {
        public static readonly YesNo No = new YesNo(0, "No");
        public static readonly YesNo Yes = new YesNo(1, "Yes");

        protected static Func<short, YesNo> GetCustom;
        protected YesNo(short value, string name) : base(value, name)
        {
        }

        protected static YesNo GetInstance(short value, string name) => new YesNo(value, name);
        public override string ToString() => $"YesNo({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(YesNo obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator YesNo(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is YesNo other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(YesNo obj1, YesNo obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(YesNo obj1, YesNo obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, YesNo obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, YesNo obj2) => !(obj1 == obj2);

        public static bool operator ==(YesNo obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(YesNo obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static YesNo GetValue(short input)
        {
            switch(input)
            {
                case var value when value == No.Value:
                return No;
                case var value when value == Yes.Value:
                return Yes;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class OnOff : GenericEnumType<short>
    {
        public static readonly OnOff Off = new OnOff(0, "Off");
        public static readonly OnOff On = new OnOff(1, "On");

        protected static Func<short, OnOff> GetCustom;
        protected OnOff(short value, string name) : base(value, name)
        {
        }

        protected static OnOff GetInstance(short value, string name) => new OnOff(value, name);
        public override string ToString() => $"OnOff({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(OnOff obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator OnOff(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is OnOff other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(OnOff obj1, OnOff obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(OnOff obj1, OnOff obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, OnOff obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, OnOff obj2) => !(obj1 == obj2);

        public static bool operator ==(OnOff obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(OnOff obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static OnOff GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Off.Value:
                return Off;
                case var value when value == On.Value:
                return On;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CorrectType : GenericEnumType<short>
    {
        public static readonly CorrectType Incorrect = new CorrectType(0, "Incorrect");
        public static readonly CorrectType Correct = new CorrectType(1, "Correct");

        protected static Func<short, CorrectType> GetCustom;
        protected CorrectType(short value, string name) : base(value, name)
        {
        }

        protected static CorrectType GetInstance(short value, string name) => new CorrectType(value, name);
        public override string ToString() => $"CorrectType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CorrectType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CorrectType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CorrectType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CorrectType obj1, CorrectType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CorrectType obj1, CorrectType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CorrectType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CorrectType obj2) => !(obj1 == obj2);

        public static bool operator ==(CorrectType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CorrectType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CorrectType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Incorrect.Value:
                return Incorrect;
                case var value when value == Correct.Value:
                return Correct;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RejectLocation : GenericEnumType<short>
    {
        public static readonly RejectLocation None = new RejectLocation(0, "None");
        public static readonly RejectLocation AfterFurnace = new RejectLocation(2, "AfterFurnace");

        protected static Func<short, RejectLocation> GetCustom;
        protected RejectLocation(short value, string name) : base(value, name)
        {
        }

        protected static RejectLocation GetInstance(short value, string name) => new RejectLocation(value, name);
        public override string ToString() => $"RejectLocation({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RejectLocation obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RejectLocation(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RejectLocation other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RejectLocation obj1, RejectLocation obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RejectLocation obj1, RejectLocation obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RejectLocation obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RejectLocation obj2) => !(obj1 == obj2);

        public static bool operator ==(RejectLocation obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RejectLocation obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RejectLocation GetValue(short input)
        {
            switch(input)
            {
                case var value when value == None.Value:
                return None;
                case var value when value == AfterFurnace.Value:
                return AfterFurnace;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TransferTableDataReadingStatus : GenericEnumType<short>
    {
        public static readonly TransferTableDataReadingStatus Undefined = new TransferTableDataReadingStatus(0, "Undefined");
        public static readonly TransferTableDataReadingStatus New = new TransferTableDataReadingStatus(1, "New");
        public static readonly TransferTableDataReadingStatus Processing = new TransferTableDataReadingStatus(2, "Processing");
        public static readonly TransferTableDataReadingStatus AttempsExceeded = new TransferTableDataReadingStatus(3, "AttempsExceeded");
        public static readonly TransferTableDataReadingStatus DataBaseError = new TransferTableDataReadingStatus(4, "DataBaseError");
        public static readonly TransferTableDataReadingStatus ProcessingInternalError = new TransferTableDataReadingStatus(5, "ProcessingInternalError");
        public static readonly TransferTableDataReadingStatus Processed = new TransferTableDataReadingStatus(6, "Processed");
        public static readonly TransferTableDataReadingStatus Canceled = new TransferTableDataReadingStatus(7, "Canceled");
        public static readonly TransferTableDataReadingStatus ForceProcessing = new TransferTableDataReadingStatus(8, "ForceProcessing");

        protected static Func<short, TransferTableDataReadingStatus> GetCustom;
        protected TransferTableDataReadingStatus(short value, string name) : base(value, name)
        {
        }

        protected static TransferTableDataReadingStatus GetInstance(short value, string name) => new TransferTableDataReadingStatus(value, name);
        public override string ToString() => $"TransferTableDataReadingStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TransferTableDataReadingStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TransferTableDataReadingStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TransferTableDataReadingStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TransferTableDataReadingStatus obj1, TransferTableDataReadingStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TransferTableDataReadingStatus obj1, TransferTableDataReadingStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TransferTableDataReadingStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TransferTableDataReadingStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(TransferTableDataReadingStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TransferTableDataReadingStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TransferTableDataReadingStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == New.Value:
                return New;
                case var value when value == Processing.Value:
                return Processing;
                case var value when value == AttempsExceeded.Value:
                return AttempsExceeded;
                case var value when value == DataBaseError.Value:
                return DataBaseError;
                case var value when value == ProcessingInternalError.Value:
                return ProcessingInternalError;
                case var value when value == Processed.Value:
                return Processed;
                case var value when value == Canceled.Value:
                return Canceled;
                case var value when value == ForceProcessing.Value:
                return ForceProcessing;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ProcessingMessageStatus : GenericEnumType<short>
    {
        public static readonly ProcessingMessageStatus NotProcessed = new ProcessingMessageStatus(0, "NotProcessed");
        public static readonly ProcessingMessageStatus Processed = new ProcessingMessageStatus(1, "Processed");

        protected static Func<short, ProcessingMessageStatus> GetCustom;
        protected ProcessingMessageStatus(short value, string name) : base(value, name)
        {
        }

        protected static ProcessingMessageStatus GetInstance(short value, string name) => new ProcessingMessageStatus(value, name);
        public override string ToString() => $"ProcessingMessageStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ProcessingMessageStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ProcessingMessageStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ProcessingMessageStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ProcessingMessageStatus obj1, ProcessingMessageStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ProcessingMessageStatus obj1, ProcessingMessageStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ProcessingMessageStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ProcessingMessageStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(ProcessingMessageStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ProcessingMessageStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ProcessingMessageStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == NotProcessed.Value:
                return NotProcessed;
                case var value when value == Processed.Value:
                return Processed;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ShiftTime : GenericEnumType<short>
    {
        public static readonly ShiftTime Undefined = new ShiftTime(0, "Undefined");
        public static readonly ShiftTime Day = new ShiftTime(1, "Day");
        public static readonly ShiftTime Afternoon = new ShiftTime(2, "Afternoon");
        public static readonly ShiftTime Night = new ShiftTime(3, "Night");

        protected static Func<short, ShiftTime> GetCustom;
        protected ShiftTime(short value, string name) : base(value, name)
        {
        }

        protected static ShiftTime GetInstance(short value, string name) => new ShiftTime(value, name);
        public override string ToString() => $"ShiftTime({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ShiftTime obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ShiftTime(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ShiftTime other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ShiftTime obj1, ShiftTime obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ShiftTime obj1, ShiftTime obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ShiftTime obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ShiftTime obj2) => !(obj1 == obj2);

        public static bool operator ==(ShiftTime obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ShiftTime obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ShiftTime GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Day.Value:
                return Day;
                case var value when value == Afternoon.Value:
                return Afternoon;
                case var value when value == Night.Value:
                return Night;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ChargeProcessingFlag : GenericEnumType<short>
    {
        public static readonly ChargeProcessingFlag UseBilletName = new ChargeProcessingFlag(0, "UseBilletName");
        public static readonly ChargeProcessingFlag UseOrderAndSeqNumber = new ChargeProcessingFlag(1, "UseOrderAndSeqNumber");

        protected static Func<short, ChargeProcessingFlag> GetCustom;
        protected ChargeProcessingFlag(short value, string name) : base(value, name)
        {
        }

        protected static ChargeProcessingFlag GetInstance(short value, string name) => new ChargeProcessingFlag(value, name);
        public override string ToString() => $"ChargeProcessingFlag({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ChargeProcessingFlag obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ChargeProcessingFlag(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ChargeProcessingFlag other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ChargeProcessingFlag obj1, ChargeProcessingFlag obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ChargeProcessingFlag obj1, ChargeProcessingFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ChargeProcessingFlag obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ChargeProcessingFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(ChargeProcessingFlag obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ChargeProcessingFlag obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ChargeProcessingFlag GetValue(short input)
        {
            switch(input)
            {
                case var value when value == UseBilletName.Value:
                return UseBilletName;
                case var value when value == UseOrderAndSeqNumber.Value:
                return UseOrderAndSeqNumber;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class DischargeProcessingFlag : GenericEnumType<short>
    {
        public static readonly DischargeProcessingFlag Default = new DischargeProcessingFlag(0, "Default");
        public static readonly DischargeProcessingFlag VerifyFurnaceBillet = new DischargeProcessingFlag(1, "VerifyFurnaceBillet");

        protected static Func<short, DischargeProcessingFlag> GetCustom;
        protected DischargeProcessingFlag(short value, string name) : base(value, name)
        {
        }

        protected static DischargeProcessingFlag GetInstance(short value, string name) => new DischargeProcessingFlag(value, name);
        public override string ToString() => $"DischargeProcessingFlag({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(DischargeProcessingFlag obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator DischargeProcessingFlag(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is DischargeProcessingFlag other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(DischargeProcessingFlag obj1, DischargeProcessingFlag obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(DischargeProcessingFlag obj1, DischargeProcessingFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, DischargeProcessingFlag obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, DischargeProcessingFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(DischargeProcessingFlag obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(DischargeProcessingFlag obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static DischargeProcessingFlag GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Default.Value:
                return Default;
                case var value when value == VerifyFurnaceBillet.Value:
                return VerifyFurnaceBillet;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class DelayStatus : GenericEnumType<short>
    {
        public static readonly DelayStatus Undefined = new DelayStatus(0, "Undefined");
        public static readonly DelayStatus Closed = new DelayStatus(1, "Closed");
        public static readonly DelayStatus Open = new DelayStatus(2, "Open");

        protected static Func<short, DelayStatus> GetCustom;
        protected DelayStatus(short value, string name) : base(value, name)
        {
        }

        protected static DelayStatus GetInstance(short value, string name) => new DelayStatus(value, name);
        public override string ToString() => $"DelayStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(DelayStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator DelayStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is DelayStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(DelayStatus obj1, DelayStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(DelayStatus obj1, DelayStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, DelayStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, DelayStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(DelayStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(DelayStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static DelayStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Closed.Value:
                return Closed;
                case var value when value == Open.Value:
                return Open;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class DelayCategory : GenericEnumType<short>
    {
        public static readonly DelayCategory Undefined = new DelayCategory(0, "Undefined");
        public static readonly DelayCategory Scheduled = new DelayCategory(1, "Scheduled");
        public static readonly DelayCategory NotScheduled = new DelayCategory(2, "NotScheduled");

        protected static Func<short, DelayCategory> GetCustom;
        protected DelayCategory(short value, string name) : base(value, name)
        {
        }

        protected static DelayCategory GetInstance(short value, string name) => new DelayCategory(value, name);
        public override string ToString() => $"DelayCategory({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(DelayCategory obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator DelayCategory(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is DelayCategory other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(DelayCategory obj1, DelayCategory obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(DelayCategory obj1, DelayCategory obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, DelayCategory obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, DelayCategory obj2) => !(obj1 == obj2);

        public static bool operator ==(DelayCategory obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(DelayCategory obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static DelayCategory GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Scheduled.Value:
                return Scheduled;
                case var value when value == NotScheduled.Value:
                return NotScheduled;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class MaintenanceRepeat : GenericEnumType<short>
    {
        public static readonly MaintenanceRepeat Never = new MaintenanceRepeat(0, "Never");
        public static readonly MaintenanceRepeat Daily = new MaintenanceRepeat(1, "Daily");
        public static readonly MaintenanceRepeat Weekly = new MaintenanceRepeat(2, "Weekly");
        public static readonly MaintenanceRepeat Monthly = new MaintenanceRepeat(3, "Monthly");
        public static readonly MaintenanceRepeat Yearly = new MaintenanceRepeat(4, "Yearly");

        protected static Func<short, MaintenanceRepeat> GetCustom;
        protected MaintenanceRepeat(short value, string name) : base(value, name)
        {
        }

        protected static MaintenanceRepeat GetInstance(short value, string name) => new MaintenanceRepeat(value, name);
        public override string ToString() => $"MaintenanceRepeat({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(MaintenanceRepeat obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator MaintenanceRepeat(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is MaintenanceRepeat other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(MaintenanceRepeat obj1, MaintenanceRepeat obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(MaintenanceRepeat obj1, MaintenanceRepeat obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, MaintenanceRepeat obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, MaintenanceRepeat obj2) => !(obj1 == obj2);

        public static bool operator ==(MaintenanceRepeat obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(MaintenanceRepeat obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static MaintenanceRepeat GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Never.Value:
                return Never;
                case var value when value == Daily.Value:
                return Daily;
                case var value when value == Weekly.Value:
                return Weekly;
                case var value when value == Monthly.Value:
                return Monthly;
                case var value when value == Yearly.Value:
                return Yearly;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class MaintenanceStatus : GenericEnumType<short>
    {
        public static readonly MaintenanceStatus Undefined = new MaintenanceStatus(0, "Undefined");
        public static readonly MaintenanceStatus Scheduled = new MaintenanceStatus(1, "Scheduled");
        public static readonly MaintenanceStatus Completed = new MaintenanceStatus(2, "Completed");
        public static readonly MaintenanceStatus Cancelled = new MaintenanceStatus(3, "Cancelled");
        public static readonly MaintenanceStatus NotCompleted = new MaintenanceStatus(4, "NotCompleted");

        protected static Func<short, MaintenanceStatus> GetCustom;
        protected MaintenanceStatus(short value, string name) : base(value, name)
        {
        }

        protected static MaintenanceStatus GetInstance(short value, string name) => new MaintenanceStatus(value, name);
        public override string ToString() => $"MaintenanceStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(MaintenanceStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator MaintenanceStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is MaintenanceStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(MaintenanceStatus obj1, MaintenanceStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(MaintenanceStatus obj1, MaintenanceStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, MaintenanceStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, MaintenanceStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(MaintenanceStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(MaintenanceStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static MaintenanceStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Scheduled.Value:
                return Scheduled;
                case var value when value == Completed.Value:
                return Completed;
                case var value when value == Cancelled.Value:
                return Cancelled;
                case var value when value == NotCompleted.Value:
                return NotCompleted;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class EquipmentStatus : GenericEnumType<short>
    {
        public static readonly EquipmentStatus Undefined = new EquipmentStatus(0, "Undefined");
        public static readonly EquipmentStatus InStock = new EquipmentStatus(1, "InStock");
        public static readonly EquipmentStatus InOperation = new EquipmentStatus(2, "InOperation");
        public static readonly EquipmentStatus Dismounted = new EquipmentStatus(3, "Dismounted");
        public static readonly EquipmentStatus Scrapped = new EquipmentStatus(4, "Scrapped");
        public static readonly EquipmentStatus Inactive = new EquipmentStatus(5, "Inactive");

        protected static Func<short, EquipmentStatus> GetCustom;
        protected EquipmentStatus(short value, string name) : base(value, name)
        {
        }

        protected static EquipmentStatus GetInstance(short value, string name) => new EquipmentStatus(value, name);
        public override string ToString() => $"EquipmentStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(EquipmentStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator EquipmentStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is EquipmentStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(EquipmentStatus obj1, EquipmentStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(EquipmentStatus obj1, EquipmentStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, EquipmentStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, EquipmentStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(EquipmentStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(EquipmentStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static EquipmentStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == InStock.Value:
                return InStock;
                case var value when value == InOperation.Value:
                return InOperation;
                case var value when value == Dismounted.Value:
                return Dismounted;
                case var value when value == Scrapped.Value:
                return Scrapped;
                case var value when value == Inactive.Value:
                return Inactive;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class EquipmentAction : GenericEnumType<short>
    {
        public static readonly EquipmentAction Undefined = new EquipmentAction(0, "Undefined");
        public static readonly EquipmentAction Check = new EquipmentAction(1, "Check");
        public static readonly EquipmentAction Replace = new EquipmentAction(2, "Replace");
        public static readonly EquipmentAction Remove = new EquipmentAction(3, "Remove");
        public static readonly EquipmentAction Repair = new EquipmentAction(4, "Repair");
        public static readonly EquipmentAction Scrap = new EquipmentAction(5, "Scrap");

        protected static Func<short, EquipmentAction> GetCustom;
        protected EquipmentAction(short value, string name) : base(value, name)
        {
        }

        protected static EquipmentAction GetInstance(short value, string name) => new EquipmentAction(value, name);
        public override string ToString() => $"EquipmentAction({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(EquipmentAction obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator EquipmentAction(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is EquipmentAction other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(EquipmentAction obj1, EquipmentAction obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(EquipmentAction obj1, EquipmentAction obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, EquipmentAction obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, EquipmentAction obj2) => !(obj1 == obj2);

        public static bool operator ==(EquipmentAction obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(EquipmentAction obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static EquipmentAction GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Check.Value:
                return Check;
                case var value when value == Replace.Value:
                return Replace;
                case var value when value == Remove.Value:
                return Remove;
                case var value when value == Repair.Value:
                return Repair;
                case var value when value == Scrap.Value:
                return Scrap;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class EquipmentResult : GenericEnumType<short>
    {
        public static readonly EquipmentResult Undefined = new EquipmentResult(0, "Undefined");
        public static readonly EquipmentResult VerifiedOk = new EquipmentResult(1, "VerifiedOk");
        public static readonly EquipmentResult Replaced = new EquipmentResult(2, "Replaced");
        public static readonly EquipmentResult Removed = new EquipmentResult(3, "Removed");
        public static readonly EquipmentResult Repaired = new EquipmentResult(4, "Repaired");
        public static readonly EquipmentResult Postponed = new EquipmentResult(5, "Postponed");
        public static readonly EquipmentResult Unsolved = new EquipmentResult(6, "Unsolved");

        protected static Func<short, EquipmentResult> GetCustom;
        protected EquipmentResult(short value, string name) : base(value, name)
        {
        }

        protected static EquipmentResult GetInstance(short value, string name) => new EquipmentResult(value, name);
        public override string ToString() => $"EquipmentResult({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(EquipmentResult obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator EquipmentResult(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is EquipmentResult other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(EquipmentResult obj1, EquipmentResult obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(EquipmentResult obj1, EquipmentResult obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, EquipmentResult obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, EquipmentResult obj2) => !(obj1 == obj2);

        public static bool operator ==(EquipmentResult obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(EquipmentResult obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static EquipmentResult GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == VerifiedOk.Value:
                return VerifiedOk;
                case var value when value == Replaced.Value:
                return Replaced;
                case var value when value == Removed.Value:
                return Removed;
                case var value when value == Repaired.Value:
                return Repaired;
                case var value when value == Postponed.Value:
                return Postponed;
                case var value when value == Unsolved.Value:
                return Unsolved;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class PlannedType : GenericEnumType<short>
    {
        public static readonly PlannedType NoPlanned = new PlannedType(0, "NoPlanned");
        public static readonly PlannedType Planned = new PlannedType(1, "Planned");

        protected static Func<short, PlannedType> GetCustom;
        protected PlannedType(short value, string name) : base(value, name)
        {
        }

        protected static PlannedType GetInstance(short value, string name) => new PlannedType(value, name);
        public override string ToString() => $"PlannedType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(PlannedType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator PlannedType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is PlannedType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(PlannedType obj1, PlannedType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(PlannedType obj1, PlannedType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, PlannedType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, PlannedType obj2) => !(obj1 == obj2);

        public static bool operator ==(PlannedType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(PlannedType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static PlannedType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == NoPlanned.Value:
                return NoPlanned;
                case var value when value == Planned.Value:
                return Planned;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class AccumulationEvent : GenericEnumType<short>
    {
        public static readonly AccumulationEvent NoEvent = new AccumulationEvent(0, "NoEvent");
        public static readonly AccumulationEvent BilletDischarged = new AccumulationEvent(1, "BilletDischarged");
        public static readonly AccumulationEvent BilletRolled = new AccumulationEvent(2, "BilletRolled");
        public static readonly AccumulationEvent ProductCreated = new AccumulationEvent(3, "ProductCreated");

        protected static Func<short, AccumulationEvent> GetCustom;
        protected AccumulationEvent(short value, string name) : base(value, name)
        {
        }

        protected static AccumulationEvent GetInstance(short value, string name) => new AccumulationEvent(value, name);
        public override string ToString() => $"AccumulationEvent({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(AccumulationEvent obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator AccumulationEvent(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is AccumulationEvent other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(AccumulationEvent obj1, AccumulationEvent obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(AccumulationEvent obj1, AccumulationEvent obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, AccumulationEvent obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, AccumulationEvent obj2) => !(obj1 == obj2);

        public static bool operator ==(AccumulationEvent obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(AccumulationEvent obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static AccumulationEvent GetValue(short input)
        {
            switch(input)
            {
                case var value when value == NoEvent.Value:
                return NoEvent;
                case var value when value == BilletDischarged.Value:
                return BilletDischarged;
                case var value when value == BilletRolled.Value:
                return BilletRolled;
                case var value when value == ProductCreated.Value:
                return ProductCreated;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class AccumulationType : GenericEnumType<short>
    {
        public static readonly AccumulationType Undefined = new AccumulationType(0, "Undefined");
        public static readonly AccumulationType PerMaterial = new AccumulationType(1, "PerMaterial");
        public static readonly AccumulationType PerTime = new AccumulationType(2, "PerTime");

        protected static Func<short, AccumulationType> GetCustom;
        protected AccumulationType(short value, string name) : base(value, name)
        {
        }

        protected static AccumulationType GetInstance(short value, string name) => new AccumulationType(value, name);
        public override string ToString() => $"AccumulationType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(AccumulationType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator AccumulationType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is AccumulationType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(AccumulationType obj1, AccumulationType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(AccumulationType obj1, AccumulationType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, AccumulationType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, AccumulationType obj2) => !(obj1 == obj2);

        public static bool operator ==(AccumulationType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(AccumulationType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static AccumulationType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == PerMaterial.Value:
                return PerMaterial;
                case var value when value == PerTime.Value:
                return PerTime;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class WorkOrderStatus : GenericEnumType<short>
    {
        public static readonly WorkOrderStatus New = new WorkOrderStatus(0, "New");
        public static readonly WorkOrderStatus Scheduled = new WorkOrderStatus(10, "Scheduled");
        public static readonly WorkOrderStatus Charging = new WorkOrderStatus(20, "Charging");
        public static readonly WorkOrderStatus Charged = new WorkOrderStatus(30, "Charged");
        public static readonly WorkOrderStatus InRealization = new WorkOrderStatus(40, "InRealization");
        public static readonly WorkOrderStatus Finished = new WorkOrderStatus(50, "Finished");
        public static readonly WorkOrderStatus Dispatched = new WorkOrderStatus(60, "Dispatched");
        public static readonly WorkOrderStatus Cancelled = new WorkOrderStatus(70, "Cancelled");

        protected static Func<short, WorkOrderStatus> GetCustom;
        protected WorkOrderStatus(short value, string name) : base(value, name)
        {
        }

        protected static WorkOrderStatus GetInstance(short value, string name) => new WorkOrderStatus(value, name);
        public override string ToString() => $"WorkOrderStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(WorkOrderStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator WorkOrderStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is WorkOrderStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(WorkOrderStatus obj1, WorkOrderStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(WorkOrderStatus obj1, WorkOrderStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, WorkOrderStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, WorkOrderStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(WorkOrderStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(WorkOrderStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static WorkOrderStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == New.Value:
                return New;
                case var value when value == Scheduled.Value:
                return Scheduled;
                case var value when value == Charging.Value:
                return Charging;
                case var value when value == Charged.Value:
                return Charged;
                case var value when value == InRealization.Value:
                return InRealization;
                case var value when value == Finished.Value:
                return Finished;
                case var value when value == Dispatched.Value:
                return Dispatched;
                case var value when value == Cancelled.Value:
                return Cancelled;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class HeatSource : GenericEnumType<short>
    {
        public static readonly HeatSource Undefined = new HeatSource(0, "Undefined");
        public static readonly HeatSource L3Input = new HeatSource(1, "L3Input");
        public static readonly HeatSource L2Hmi = new HeatSource(2, "L2Hmi");
        public static readonly HeatSource L1Input = new HeatSource(3, "L1Input");

        protected static Func<short, HeatSource> GetCustom;
        protected HeatSource(short value, string name) : base(value, name)
        {
        }

        protected static HeatSource GetInstance(short value, string name) => new HeatSource(value, name);
        public override string ToString() => $"HeatSource({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(HeatSource obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator HeatSource(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is HeatSource other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(HeatSource obj1, HeatSource obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(HeatSource obj1, HeatSource obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, HeatSource obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, HeatSource obj2) => !(obj1 == obj2);

        public static bool operator ==(HeatSource obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(HeatSource obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static HeatSource GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == L3Input.Value:
                return L3Input;
                case var value when value == L2Hmi.Value:
                return L2Hmi;
                case var value when value == L1Input.Value:
                return L1Input;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class LenghtType : GenericEnumType<short>
    {
        public static readonly LenghtType Trading = new LenghtType(0, "Trading");
        public static readonly LenghtType Specified = new LenghtType(1, "Specified");
        public static readonly LenghtType Combined = new LenghtType(2, "Combined");

        protected static Func<short, LenghtType> GetCustom;
        protected LenghtType(short value, string name) : base(value, name)
        {
        }

        protected static LenghtType GetInstance(short value, string name) => new LenghtType(value, name);
        public override string ToString() => $"LenghtType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(LenghtType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator LenghtType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is LenghtType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(LenghtType obj1, LenghtType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(LenghtType obj1, LenghtType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, LenghtType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, LenghtType obj2) => !(obj1 == obj2);

        public static bool operator ==(LenghtType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(LenghtType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static LenghtType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Trading.Value:
                return Trading;
                case var value when value == Specified.Value:
                return Specified;
                case var value when value == Combined.Value:
                return Combined;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class NewProductProcessingFlag : GenericEnumType<short>
    {
        public static readonly NewProductProcessingFlag Default = new NewProductProcessingFlag(0, "Default");
        public static readonly NewProductProcessingFlag CusomerSpecific1 = new NewProductProcessingFlag(1, "CusomerSpecific1");
        public static readonly NewProductProcessingFlag CusomerSpecific2 = new NewProductProcessingFlag(2, "CusomerSpecific2");
        public static readonly NewProductProcessingFlag CusomerSpecific3 = new NewProductProcessingFlag(3, "CusomerSpecific3");

        protected static Func<short, NewProductProcessingFlag> GetCustom;
        protected NewProductProcessingFlag(short value, string name) : base(value, name)
        {
        }

        protected static NewProductProcessingFlag GetInstance(short value, string name) => new NewProductProcessingFlag(value, name);
        public override string ToString() => $"NewProductProcessingFlag({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(NewProductProcessingFlag obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator NewProductProcessingFlag(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is NewProductProcessingFlag other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(NewProductProcessingFlag obj1, NewProductProcessingFlag obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(NewProductProcessingFlag obj1, NewProductProcessingFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, NewProductProcessingFlag obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, NewProductProcessingFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(NewProductProcessingFlag obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(NewProductProcessingFlag obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static NewProductProcessingFlag GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Default.Value:
                return Default;
                case var value when value == CusomerSpecific1.Value:
                return CusomerSpecific1;
                case var value when value == CusomerSpecific2.Value:
                return CusomerSpecific2;
                case var value when value == CusomerSpecific3.Value:
                return CusomerSpecific3;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class HeatFlag : GenericEnumType<short>
    {
        public static readonly HeatFlag Undefined = new HeatFlag(0, "Undefined");
        public static readonly HeatFlag Suspected = new HeatFlag(1, "Suspected");
        public static readonly HeatFlag Alarm = new HeatFlag(2, "Alarm");
        public static readonly HeatFlag Critical = new HeatFlag(3, "Critical");

        protected static Func<short, HeatFlag> GetCustom;
        protected HeatFlag(short value, string name) : base(value, name)
        {
        }

        protected static HeatFlag GetInstance(short value, string name) => new HeatFlag(value, name);
        public override string ToString() => $"HeatFlag({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(HeatFlag obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator HeatFlag(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is HeatFlag other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(HeatFlag obj1, HeatFlag obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(HeatFlag obj1, HeatFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, HeatFlag obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, HeatFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(HeatFlag obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(HeatFlag obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static HeatFlag GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Suspected.Value:
                return Suspected;
                case var value when value == Alarm.Value:
                return Alarm;
                case var value when value == Critical.Value:
                return Critical;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class HeatStatus : GenericEnumType<short>
    {
        public static readonly HeatStatus Invalid = new HeatStatus(0, "Invalid");
        public static readonly HeatStatus New = new HeatStatus(1, "New");
        public static readonly HeatStatus InProduction = new HeatStatus(2, "InProduction");
        public static readonly HeatStatus Produced = new HeatStatus(3, "Produced");
        public static readonly HeatStatus Scrapped = new HeatStatus(4, "Scrapped");

        protected static Func<short, HeatStatus> GetCustom;
        protected HeatStatus(short value, string name) : base(value, name)
        {
        }

        protected static HeatStatus GetInstance(short value, string name) => new HeatStatus(value, name);
        public override string ToString() => $"HeatStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(HeatStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator HeatStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is HeatStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(HeatStatus obj1, HeatStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(HeatStatus obj1, HeatStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, HeatStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, HeatStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(HeatStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(HeatStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static HeatStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Invalid.Value:
                return Invalid;
                case var value when value == New.Value:
                return New;
                case var value when value == InProduction.Value:
                return InProduction;
                case var value when value == Produced.Value:
                return Produced;
                case var value when value == Scrapped.Value:
                return Scrapped;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RawMaterialStatus : GenericEnumType<short>
    {
        public static readonly RawMaterialStatus Invalid = new RawMaterialStatus(0, "Invalid");
        public static readonly RawMaterialStatus Unassigned = new RawMaterialStatus(10, "Unassigned");
        public static readonly RawMaterialStatus Assigned = new RawMaterialStatus(20, "Assigned");
        public static readonly RawMaterialStatus Charged = new RawMaterialStatus(30, "Charged");
        public static readonly RawMaterialStatus Discharged = new RawMaterialStatus(40, "Discharged");
        public static readonly RawMaterialStatus InStorage = new RawMaterialStatus(50, "InStorage");
        public static readonly RawMaterialStatus InMill = new RawMaterialStatus(60, "InMill");
        public static readonly RawMaterialStatus InFinalProduction = new RawMaterialStatus(70, "InFinalProduction");
        public static readonly RawMaterialStatus OnCoolingBed = new RawMaterialStatus(80, "OnCoolingBed");
        public static readonly RawMaterialStatus Rolled = new RawMaterialStatus(90, "Rolled");
        public static readonly RawMaterialStatus InTransport = new RawMaterialStatus(100, "InTransport");
        public static readonly RawMaterialStatus Finished = new RawMaterialStatus(110, "Finished");
        public static readonly RawMaterialStatus Scrap = new RawMaterialStatus(120, "Scrap");
        public static readonly RawMaterialStatus Rejected = new RawMaterialStatus(130, "Rejected");
        public static readonly RawMaterialStatus Divided = new RawMaterialStatus(140, "Divided");

        protected static Func<short, RawMaterialStatus> GetCustom;
        protected RawMaterialStatus(short value, string name) : base(value, name)
        {
        }

        protected static RawMaterialStatus GetInstance(short value, string name) => new RawMaterialStatus(value, name);
        public override string ToString() => $"RawMaterialStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RawMaterialStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RawMaterialStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RawMaterialStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RawMaterialStatus obj1, RawMaterialStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RawMaterialStatus obj1, RawMaterialStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RawMaterialStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RawMaterialStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(RawMaterialStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RawMaterialStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RawMaterialStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Invalid.Value:
                return Invalid;
                case var value when value == Unassigned.Value:
                return Unassigned;
                case var value when value == Assigned.Value:
                return Assigned;
                case var value when value == Charged.Value:
                return Charged;
                case var value when value == Discharged.Value:
                return Discharged;
                case var value when value == InStorage.Value:
                return InStorage;
                case var value when value == InMill.Value:
                return InMill;
                case var value when value == InFinalProduction.Value:
                return InFinalProduction;
                case var value when value == OnCoolingBed.Value:
                return OnCoolingBed;
                case var value when value == Rolled.Value:
                return Rolled;
                case var value when value == InTransport.Value:
                return InTransport;
                case var value when value == Finished.Value:
                return Finished;
                case var value when value == Scrap.Value:
                return Scrap;
                case var value when value == Rejected.Value:
                return Rejected;
                case var value when value == Divided.Value:
                return Divided;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RejectFlag : GenericEnumType<short>
    {
        public static readonly RejectFlag NotRejected = new RejectFlag(0, "NotRejected");
        public static readonly RejectFlag Heating = new RejectFlag(1, "Heating");
        public static readonly RejectFlag Dimension = new RejectFlag(2, "Dimension");
        public static readonly RejectFlag Unscheduled = new RejectFlag(3, "Unscheduled");

        protected static Func<short, RejectFlag> GetCustom;
        protected RejectFlag(short value, string name) : base(value, name)
        {
        }

        protected static RejectFlag GetInstance(short value, string name) => new RejectFlag(value, name);
        public override string ToString() => $"RejectFlag({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RejectFlag obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RejectFlag(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RejectFlag other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RejectFlag obj1, RejectFlag obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RejectFlag obj1, RejectFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RejectFlag obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RejectFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(RejectFlag obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RejectFlag obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RejectFlag GetValue(short input)
        {
            switch(input)
            {
                case var value when value == NotRejected.Value:
                return NotRejected;
                case var value when value == Heating.Value:
                return Heating;
                case var value when value == Dimension.Value:
                return Dimension;
                case var value when value == Unscheduled.Value:
                return Unscheduled;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RawMaterialType : GenericEnumType<short>
    {
        public static readonly RawMaterialType Material = new RawMaterialType(0, "Material");
        public static readonly RawMaterialType Layer = new RawMaterialType(1, "Layer");
        public static readonly RawMaterialType Bundle = new RawMaterialType(2, "Bundle");

        protected static Func<short, RawMaterialType> GetCustom;
        protected RawMaterialType(short value, string name) : base(value, name)
        {
        }

        protected static RawMaterialType GetInstance(short value, string name) => new RawMaterialType(value, name);
        public override string ToString() => $"RawMaterialType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RawMaterialType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RawMaterialType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RawMaterialType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RawMaterialType obj1, RawMaterialType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RawMaterialType obj1, RawMaterialType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RawMaterialType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RawMaterialType obj2) => !(obj1 == obj2);

        public static bool operator ==(RawMaterialType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RawMaterialType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RawMaterialType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Material.Value:
                return Material;
                case var value when value == Layer.Value:
                return Layer;
                case var value when value == Bundle.Value:
                return Bundle;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RawMaterialStepNo : GenericEnumType<short>
    {
        public static readonly RawMaterialStepNo OverallStep = new RawMaterialStepNo(0, "OverallStep");
        public static readonly RawMaterialStepNo FirstStep = new RawMaterialStepNo(1, "FirstStep");
        public static readonly RawMaterialStepNo FirstProcessingLineStep = new RawMaterialStepNo(2, "FirstProcessingLineStep");

        protected static Func<short, RawMaterialStepNo> GetCustom;
        protected RawMaterialStepNo(short value, string name) : base(value, name)
        {
        }

        protected static RawMaterialStepNo GetInstance(short value, string name) => new RawMaterialStepNo(value, name);
        public override string ToString() => $"RawMaterialStepNo({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RawMaterialStepNo obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RawMaterialStepNo(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RawMaterialStepNo other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RawMaterialStepNo obj1, RawMaterialStepNo obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RawMaterialStepNo obj1, RawMaterialStepNo obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RawMaterialStepNo obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RawMaterialStepNo obj2) => !(obj1 == obj2);

        public static bool operator ==(RawMaterialStepNo obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RawMaterialStepNo obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RawMaterialStepNo GetValue(short input)
        {
            switch(input)
            {
                case var value when value == OverallStep.Value:
                return OverallStep;
                case var value when value == FirstStep.Value:
                return FirstStep;
                case var value when value == FirstProcessingLineStep.Value:
                return FirstProcessingLineStep;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ReportType : GenericEnumType<short>
    {
        public static readonly ReportType PDF = new ReportType(0, "PDF");
        public static readonly ReportType XLS = new ReportType(1, "XLS");

        protected static Func<short, ReportType> GetCustom;
        protected ReportType(short value, string name) : base(value, name)
        {
        }

        protected static ReportType GetInstance(short value, string name) => new ReportType(value, name);
        public override string ToString() => $"ReportType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ReportType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ReportType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ReportType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ReportType obj1, ReportType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ReportType obj1, ReportType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ReportType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ReportType obj2) => !(obj1 == obj2);

        public static bool operator ==(ReportType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ReportType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ReportType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == PDF.Value:
                return PDF;
                case var value when value == XLS.Value:
                return XLS;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ProductionReportNames : GenericEnumType<short>
    {
        public static readonly ProductionReportNames ProductionReport = new ProductionReportNames(0, "ProductionReport");
        public static readonly ProductionReportNames CompactProductionReport = new ProductionReportNames(1, "CompactProductionReport");

        protected static Func<short, ProductionReportNames> GetCustom;
        protected ProductionReportNames(short value, string name) : base(value, name)
        {
        }

        protected static ProductionReportNames GetInstance(short value, string name) => new ProductionReportNames(value, name);
        public override string ToString() => $"ProductionReportNames({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ProductionReportNames obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ProductionReportNames(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ProductionReportNames other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ProductionReportNames obj1, ProductionReportNames obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ProductionReportNames obj1, ProductionReportNames obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ProductionReportNames obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ProductionReportNames obj2) => !(obj1 == obj2);

        public static bool operator ==(ProductionReportNames obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ProductionReportNames obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ProductionReportNames GetValue(short input)
        {
            switch(input)
            {
                case var value when value == ProductionReport.Value:
                return ProductionReport;
                case var value when value == CompactProductionReport.Value:
                return CompactProductionReport;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ProductStatus : GenericEnumType<short>
    {
        public static readonly ProductStatus Invalid = new ProductStatus(0, "Invalid");
        public static readonly ProductStatus Produced = new ProductStatus(1, "Produced");
        public static readonly ProductStatus InTransport = new ProductStatus(2, "InTransport");
        public static readonly ProductStatus InProductYard = new ProductStatus(3, "InProductYard");
        public static readonly ProductStatus OutForDelivery = new ProductStatus(4, "OutForDelivery");
        public static readonly ProductStatus Scrapped = new ProductStatus(5, "Scrapped");
        public static readonly ProductStatus PalletArea = new ProductStatus(6, "PalletArea");

        protected static Func<short, ProductStatus> GetCustom;
        protected ProductStatus(short value, string name) : base(value, name)
        {
        }

        protected static ProductStatus GetInstance(short value, string name) => new ProductStatus(value, name);
        public override string ToString() => $"ProductStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ProductStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ProductStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ProductStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ProductStatus obj1, ProductStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ProductStatus obj1, ProductStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ProductStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ProductStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(ProductStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ProductStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ProductStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Invalid.Value:
                return Invalid;
                case var value when value == Produced.Value:
                return Produced;
                case var value when value == InTransport.Value:
                return InTransport;
                case var value when value == InProductYard.Value:
                return InProductYard;
                case var value when value == OutForDelivery.Value:
                return OutForDelivery;
                case var value when value == Scrapped.Value:
                return Scrapped;
                case var value when value == PalletArea.Value:
                return PalletArea;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ProductQuality : GenericEnumType<short>
    {
        public static readonly ProductQuality NotEvaluated = new ProductQuality(0, "NotEvaluated");
        public static readonly ProductQuality QualityOK = new ProductQuality(1, "QualityOK");
        public static readonly ProductQuality QualityScrap = new ProductQuality(2, "QualityScrap");

        protected static Func<short, ProductQuality> GetCustom;
        protected ProductQuality(short value, string name) : base(value, name)
        {
        }

        protected static ProductQuality GetInstance(short value, string name) => new ProductQuality(value, name);
        public override string ToString() => $"ProductQuality({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ProductQuality obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ProductQuality(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ProductQuality other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ProductQuality obj1, ProductQuality obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ProductQuality obj1, ProductQuality obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ProductQuality obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ProductQuality obj2) => !(obj1 == obj2);

        public static bool operator ==(ProductQuality obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ProductQuality obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ProductQuality GetValue(short input)
        {
            switch(input)
            {
                case var value when value == NotEvaluated.Value:
                return NotEvaluated;
                case var value when value == QualityOK.Value:
                return QualityOK;
                case var value when value == QualityScrap.Value:
                return QualityScrap;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class HeatingStatus : GenericEnumType<short>
    {
        public static readonly HeatingStatus Undefined = new HeatingStatus(0, "Undefined");
        public static readonly HeatingStatus HeatingNotFinished = new HeatingStatus(1, "HeatingNotFinished");
        public static readonly HeatingStatus HeatingTimeOK = new HeatingStatus(2, "HeatingTimeOK");
        public static readonly HeatingStatus HeatingTimeExceedRisk = new HeatingStatus(3, "HeatingTimeExceedRisk");
        public static readonly HeatingStatus HeatingTimeExceeded = new HeatingStatus(4, "HeatingTimeExceeded");

        protected static Func<short, HeatingStatus> GetCustom;
        protected HeatingStatus(short value, string name) : base(value, name)
        {
        }

        protected static HeatingStatus GetInstance(short value, string name) => new HeatingStatus(value, name);
        public override string ToString() => $"HeatingStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(HeatingStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator HeatingStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is HeatingStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(HeatingStatus obj1, HeatingStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(HeatingStatus obj1, HeatingStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, HeatingStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, HeatingStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(HeatingStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(HeatingStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static HeatingStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == HeatingNotFinished.Value:
                return HeatingNotFinished;
                case var value when value == HeatingTimeOK.Value:
                return HeatingTimeOK;
                case var value when value == HeatingTimeExceedRisk.Value:
                return HeatingTimeExceedRisk;
                case var value when value == HeatingTimeExceeded.Value:
                return HeatingTimeExceeded;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class DivisionFlag : GenericEnumType<short>
    {
        public static readonly DivisionFlag Undefined = new DivisionFlag(0, "Undefined");
        public static readonly DivisionFlag DividedAndOriginal = new DivisionFlag(1, "DividedAndOriginal");
        public static readonly DivisionFlag DividedAndNew = new DivisionFlag(2, "DividedAndNew");

        protected static Func<short, DivisionFlag> GetCustom;
        protected DivisionFlag(short value, string name) : base(value, name)
        {
        }

        protected static DivisionFlag GetInstance(short value, string name) => new DivisionFlag(value, name);
        public override string ToString() => $"DivisionFlag({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(DivisionFlag obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator DivisionFlag(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is DivisionFlag other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(DivisionFlag obj1, DivisionFlag obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(DivisionFlag obj1, DivisionFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, DivisionFlag obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, DivisionFlag obj2) => !(obj1 == obj2);

        public static bool operator ==(DivisionFlag obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(DivisionFlag obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static DivisionFlag GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == DividedAndOriginal.Value:
                return DividedAndOriginal;
                case var value when value == DividedAndNew.Value:
                return DividedAndNew;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class WeightSource : GenericEnumType<short>
    {
        public static readonly WeightSource Undefined = new WeightSource(0, "Undefined");
        public static readonly WeightSource Calculated = new WeightSource(1, "Calculated");
        public static readonly WeightSource Measured = new WeightSource(2, "Measured");
        public static readonly WeightSource Operator = new WeightSource(3, "Operator");
        public static readonly WeightSource Theoretical = new WeightSource(4, "Theoretical");
        public static readonly WeightSource FromMaterial = new WeightSource(5, "FromMaterial");

        protected static Func<short, WeightSource> GetCustom;
        protected WeightSource(short value, string name) : base(value, name)
        {
        }

        protected static WeightSource GetInstance(short value, string name) => new WeightSource(value, name);
        public override string ToString() => $"WeightSource({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(WeightSource obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator WeightSource(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is WeightSource other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(WeightSource obj1, WeightSource obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(WeightSource obj1, WeightSource obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, WeightSource obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, WeightSource obj2) => !(obj1 == obj2);

        public static bool operator ==(WeightSource obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(WeightSource obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static WeightSource GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Calculated.Value:
                return Calculated;
                case var value when value == Measured.Value:
                return Measured;
                case var value when value == Operator.Value:
                return Operator;
                case var value when value == Theoretical.Value:
                return Theoretical;
                case var value when value == FromMaterial.Value:
                return FromMaterial;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ProductType : GenericEnumType<short>
    {
        public static readonly ProductType Product = new ProductType(0, "Product");
        public static readonly ProductType ScrapMill = new ProductType(1, "ScrapMill");
        public static readonly ProductType Scrap = new ProductType(2, "Scrap");

        protected static Func<short, ProductType> GetCustom;
        protected ProductType(short value, string name) : base(value, name)
        {
        }

        protected static ProductType GetInstance(short value, string name) => new ProductType(value, name);
        public override string ToString() => $"ProductType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ProductType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ProductType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ProductType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ProductType obj1, ProductType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ProductType obj1, ProductType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ProductType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ProductType obj2) => !(obj1 == obj2);

        public static bool operator ==(ProductType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ProductType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ProductType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Product.Value:
                return Product;
                case var value when value == ScrapMill.Value:
                return ScrapMill;
                case var value when value == Scrap.Value:
                return Scrap;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class WeightStatus : GenericEnumType<short>
    {
        public static readonly WeightStatus NotWeighed = new WeightStatus(0, "NotWeighed");
        public static readonly WeightStatus WeightFromCradle1 = new WeightStatus(1, "WeightFromCradle1");
        public static readonly WeightStatus WeightFromCradle2 = new WeightStatus(2, "WeightFromCradle2");
        public static readonly WeightStatus WeightFromScale = new WeightStatus(9, "WeightFromScale");

        protected static Func<short, WeightStatus> GetCustom;
        protected WeightStatus(short value, string name) : base(value, name)
        {
        }

        protected static WeightStatus GetInstance(short value, string name) => new WeightStatus(value, name);
        public override string ToString() => $"WeightStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(WeightStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator WeightStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is WeightStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(WeightStatus obj1, WeightStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(WeightStatus obj1, WeightStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, WeightStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, WeightStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(WeightStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(WeightStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static WeightStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == NotWeighed.Value:
                return NotWeighed;
                case var value when value == WeightFromCradle1.Value:
                return WeightFromCradle1;
                case var value when value == WeightFromCradle2.Value:
                return WeightFromCradle2;
                case var value when value == WeightFromScale.Value:
                return WeightFromScale;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class BilletHeatSource : GenericEnumType<short>
    {
        public static readonly BilletHeatSource Undefined = new BilletHeatSource(0, "Undefined");

        protected static Func<short, BilletHeatSource> GetCustom;
        protected BilletHeatSource(short value, string name) : base(value, name)
        {
        }

        protected static BilletHeatSource GetInstance(short value, string name) => new BilletHeatSource(value, name);
        public override string ToString() => $"BilletHeatSource({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(BilletHeatSource obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator BilletHeatSource(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is BilletHeatSource other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(BilletHeatSource obj1, BilletHeatSource obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(BilletHeatSource obj1, BilletHeatSource obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, BilletHeatSource obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, BilletHeatSource obj2) => !(obj1 == obj2);

        public static bool operator ==(BilletHeatSource obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(BilletHeatSource obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static BilletHeatSource GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class PitFurnaceStatus : GenericEnumType<short>
    {
        public static readonly PitFurnaceStatus Undefined = new PitFurnaceStatus(0, "Undefined");
        public static readonly PitFurnaceStatus InOperation = new PitFurnaceStatus(1, "InOperation");
        public static readonly PitFurnaceStatus ShutDown = new PitFurnaceStatus(2, "ShutDown");
        public static readonly PitFurnaceStatus Disabled = new PitFurnaceStatus(3, "Disabled");

        protected static Func<short, PitFurnaceStatus> GetCustom;
        protected PitFurnaceStatus(short value, string name) : base(value, name)
        {
        }

        protected static PitFurnaceStatus GetInstance(short value, string name) => new PitFurnaceStatus(value, name);
        public override string ToString() => $"PitFurnaceStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(PitFurnaceStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator PitFurnaceStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is PitFurnaceStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(PitFurnaceStatus obj1, PitFurnaceStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(PitFurnaceStatus obj1, PitFurnaceStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, PitFurnaceStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, PitFurnaceStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(PitFurnaceStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(PitFurnaceStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static PitFurnaceStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == InOperation.Value:
                return InOperation;
                case var value when value == ShutDown.Value:
                return ShutDown;
                case var value when value == Disabled.Value:
                return Disabled;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ChargeType : GenericEnumType<short>
    {
        public static readonly ChargeType Undefined = new ChargeType(0, "Undefined");
        public static readonly ChargeType SingleMaterial = new ChargeType(1, "SingleMaterial");
        public static readonly ChargeType BatchOfMaterials = new ChargeType(2, "BatchOfMaterials");

        protected static Func<short, ChargeType> GetCustom;
        protected ChargeType(short value, string name) : base(value, name)
        {
        }

        protected static ChargeType GetInstance(short value, string name) => new ChargeType(value, name);
        public override string ToString() => $"ChargeType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ChargeType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ChargeType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ChargeType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ChargeType obj1, ChargeType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ChargeType obj1, ChargeType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ChargeType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ChargeType obj2) => !(obj1 == obj2);

        public static bool operator ==(ChargeType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ChargeType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ChargeType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == SingleMaterial.Value:
                return SingleMaterial;
                case var value when value == BatchOfMaterials.Value:
                return BatchOfMaterials;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class MaterialShapeType : GenericEnumType<short>
    {
        public static readonly MaterialShapeType Undefined = new MaterialShapeType(0, "Undefined");
        public static readonly MaterialShapeType SquareSmall = new MaterialShapeType(1, "SquareSmall");
        public static readonly MaterialShapeType SquareMedium = new MaterialShapeType(2, "SquareMedium");
        public static readonly MaterialShapeType SquareLarge = new MaterialShapeType(3, "SquareLarge");
        public static readonly MaterialShapeType RoundSquareSmall = new MaterialShapeType(4, "RoundSquareSmall");
        public static readonly MaterialShapeType RoundSquareMedium = new MaterialShapeType(5, "RoundSquareMedium");
        public static readonly MaterialShapeType RoundSquareLarge = new MaterialShapeType(6, "RoundSquareLarge");
        public static readonly MaterialShapeType RoundSmall = new MaterialShapeType(7, "RoundSmall");
        public static readonly MaterialShapeType RoundMedium = new MaterialShapeType(8, "RoundMedium");
        public static readonly MaterialShapeType RoundLarge = new MaterialShapeType(9, "RoundLarge");
        public static readonly MaterialShapeType FlatSmall = new MaterialShapeType(10, "FlatSmall");
        public static readonly MaterialShapeType FlatMedium = new MaterialShapeType(11, "FlatMedium");
        public static readonly MaterialShapeType FlatLarge = new MaterialShapeType(12, "FlatLarge");
        public static readonly MaterialShapeType BatchOfMaterials = new MaterialShapeType(99, "BatchOfMaterials");

        protected static Func<short, MaterialShapeType> GetCustom;
        protected MaterialShapeType(short value, string name) : base(value, name)
        {
        }

        protected static MaterialShapeType GetInstance(short value, string name) => new MaterialShapeType(value, name);
        public override string ToString() => $"MaterialShapeType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(MaterialShapeType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator MaterialShapeType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is MaterialShapeType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(MaterialShapeType obj1, MaterialShapeType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(MaterialShapeType obj1, MaterialShapeType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, MaterialShapeType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, MaterialShapeType obj2) => !(obj1 == obj2);

        public static bool operator ==(MaterialShapeType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(MaterialShapeType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static MaterialShapeType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == SquareSmall.Value:
                return SquareSmall;
                case var value when value == SquareMedium.Value:
                return SquareMedium;
                case var value when value == SquareLarge.Value:
                return SquareLarge;
                case var value when value == RoundSquareSmall.Value:
                return RoundSquareSmall;
                case var value when value == RoundSquareMedium.Value:
                return RoundSquareMedium;
                case var value when value == RoundSquareLarge.Value:
                return RoundSquareLarge;
                case var value when value == RoundSmall.Value:
                return RoundSmall;
                case var value when value == RoundMedium.Value:
                return RoundMedium;
                case var value when value == RoundLarge.Value:
                return RoundLarge;
                case var value when value == FlatSmall.Value:
                return FlatSmall;
                case var value when value == FlatMedium.Value:
                return FlatMedium;
                case var value when value == FlatLarge.Value:
                return FlatLarge;
                case var value when value == BatchOfMaterials.Value:
                return BatchOfMaterials;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class DailyPlanStatus : GenericEnumType<short>
    {
        public static readonly DailyPlanStatus Undefined = new DailyPlanStatus(0, "Undefined");
        public static readonly DailyPlanStatus InPreparation = new DailyPlanStatus(1, "InPreparation");
        public static readonly DailyPlanStatus Released = new DailyPlanStatus(2, "Released");
        public static readonly DailyPlanStatus Completed = new DailyPlanStatus(3, "Completed");

        protected static Func<short, DailyPlanStatus> GetCustom;
        protected DailyPlanStatus(short value, string name) : base(value, name)
        {
        }

        protected static DailyPlanStatus GetInstance(short value, string name) => new DailyPlanStatus(value, name);
        public override string ToString() => $"DailyPlanStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(DailyPlanStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator DailyPlanStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is DailyPlanStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(DailyPlanStatus obj1, DailyPlanStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(DailyPlanStatus obj1, DailyPlanStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, DailyPlanStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, DailyPlanStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(DailyPlanStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(DailyPlanStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static DailyPlanStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == InPreparation.Value:
                return InPreparation;
                case var value when value == Released.Value:
                return Released;
                case var value when value == Completed.Value:
                return Completed;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class IsTestOrder : GenericEnumType<short>
    {
        public static readonly IsTestOrder NoTest = new IsTestOrder(0, "NoTest");
        public static readonly IsTestOrder IsTest = new IsTestOrder(1, "IsTest");

        protected static Func<short, IsTestOrder> GetCustom;
        protected IsTestOrder(short value, string name) : base(value, name)
        {
        }

        protected static IsTestOrder GetInstance(short value, string name) => new IsTestOrder(value, name);
        public override string ToString() => $"IsTestOrder({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(IsTestOrder obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator IsTestOrder(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is IsTestOrder other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(IsTestOrder obj1, IsTestOrder obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(IsTestOrder obj1, IsTestOrder obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, IsTestOrder obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, IsTestOrder obj2) => !(obj1 == obj2);

        public static bool operator ==(IsTestOrder obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(IsTestOrder obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static IsTestOrder GetValue(short input)
        {
            switch(input)
            {
                case var value when value == NoTest.Value:
                return NoTest;
                case var value when value == IsTest.Value:
                return IsTest;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class OperationType : GenericEnumType<short>
    {
        public static readonly OperationType Add = new OperationType(0, "Add");
        public static readonly OperationType Delete = new OperationType(1, "Delete");

        protected static Func<short, OperationType> GetCustom;
        protected OperationType(short value, string name) : base(value, name)
        {
        }

        protected static OperationType GetInstance(short value, string name) => new OperationType(value, name);
        public override string ToString() => $"OperationType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(OperationType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator OperationType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is OperationType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(OperationType obj1, OperationType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(OperationType obj1, OperationType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, OperationType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, OperationType obj2) => !(obj1 == obj2);

        public static bool operator ==(OperationType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(OperationType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static OperationType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Add.Value:
                return Add;
                case var value when value == Delete.Value:
                return Delete;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class MillStatus : GenericEnumType<short>
    {
        public static readonly MillStatus NotWorking = new MillStatus(0, "NotWorking");
        public static readonly MillStatus Working = new MillStatus(1, "Working");

        protected static Func<short, MillStatus> GetCustom;
        protected MillStatus(short value, string name) : base(value, name)
        {
        }

        protected static MillStatus GetInstance(short value, string name) => new MillStatus(value, name);
        public override string ToString() => $"MillStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(MillStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator MillStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is MillStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(MillStatus obj1, MillStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(MillStatus obj1, MillStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, MillStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, MillStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(MillStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(MillStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static MillStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == NotWorking.Value:
                return NotWorking;
                case var value when value == Working.Value:
                return Working;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class LaboratoryCode : GenericEnumType<short>
    {
        public static readonly LaboratoryCode InputMaterialData = new LaboratoryCode(0, "InputMaterialData");

        protected static Func<short, LaboratoryCode> GetCustom;
        protected LaboratoryCode(short value, string name) : base(value, name)
        {
        }

        protected static LaboratoryCode GetInstance(short value, string name) => new LaboratoryCode(value, name);
        public override string ToString() => $"LaboratoryCode({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(LaboratoryCode obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator LaboratoryCode(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is LaboratoryCode other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(LaboratoryCode obj1, LaboratoryCode obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(LaboratoryCode obj1, LaboratoryCode obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, LaboratoryCode obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, LaboratoryCode obj2) => !(obj1 == obj2);

        public static bool operator ==(LaboratoryCode obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(LaboratoryCode obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static LaboratoryCode GetValue(short input)
        {
            switch(input)
            {
                case var value when value == InputMaterialData.Value:
                return InputMaterialData;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TypeOfCut : GenericEnumType<short>
    {
        public static readonly TypeOfCut Undefined = new TypeOfCut(0, "Undefined");
        public static readonly TypeOfCut HeadCut = new TypeOfCut(1, "HeadCut");
        public static readonly TypeOfCut TailCut = new TypeOfCut(2, "TailCut");
        public static readonly TypeOfCut SampleCut = new TypeOfCut(3, "SampleCut");
        public static readonly TypeOfCut ManualChopping = new TypeOfCut(4, "ManualChopping");
        public static readonly TypeOfCut AutoChopping = new TypeOfCut(5, "AutoChopping");
        public static readonly TypeOfCut EmergencyCut = new TypeOfCut(6, "EmergencyCut");
        public static readonly TypeOfCut DivideCut = new TypeOfCut(10, "DivideCut");

        protected static Func<short, TypeOfCut> GetCustom;
        protected TypeOfCut(short value, string name) : base(value, name)
        {
        }

        protected static TypeOfCut GetInstance(short value, string name) => new TypeOfCut(value, name);
        public override string ToString() => $"TypeOfCut({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TypeOfCut obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TypeOfCut(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TypeOfCut other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TypeOfCut obj1, TypeOfCut obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TypeOfCut obj1, TypeOfCut obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TypeOfCut obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TypeOfCut obj2) => !(obj1 == obj2);

        public static bool operator ==(TypeOfCut obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TypeOfCut obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TypeOfCut GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == HeadCut.Value:
                return HeadCut;
                case var value when value == TailCut.Value:
                return TailCut;
                case var value when value == SampleCut.Value:
                return SampleCut;
                case var value when value == ManualChopping.Value:
                return ManualChopping;
                case var value when value == AutoChopping.Value:
                return AutoChopping;
                case var value when value == EmergencyCut.Value:
                return EmergencyCut;
                case var value when value == DivideCut.Value:
                return DivideCut;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class EvalExecutionStatus : GenericEnumType<short>
    {
        public static readonly EvalExecutionStatus Undefined = new EvalExecutionStatus(0, "Undefined");
        public static readonly EvalExecutionStatus SUCCESS = new EvalExecutionStatus(1, "SUCCESS");
        public static readonly EvalExecutionStatus FAILED = new EvalExecutionStatus(2, "FAILED");

        protected static Func<short, EvalExecutionStatus> GetCustom;
        protected EvalExecutionStatus(short value, string name) : base(value, name)
        {
        }

        protected static EvalExecutionStatus GetInstance(short value, string name) => new EvalExecutionStatus(value, name);
        public override string ToString() => $"EvalExecutionStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(EvalExecutionStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator EvalExecutionStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is EvalExecutionStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(EvalExecutionStatus obj1, EvalExecutionStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(EvalExecutionStatus obj1, EvalExecutionStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, EvalExecutionStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, EvalExecutionStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(EvalExecutionStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(EvalExecutionStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static EvalExecutionStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == SUCCESS.Value:
                return SUCCESS;
                case var value when value == FAILED.Value:
                return FAILED;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class Aggregation : GenericEnumType<short>
    {
        public static readonly Aggregation UNKNOWN = new Aggregation(-1, "UNKNOWN");
        public static readonly Aggregation ZERO = new Aggregation(0, "ZERO");
        public static readonly Aggregation FIRST = new Aggregation(1, "FIRST");
        public static readonly Aggregation LAST = new Aggregation(2, "LAST");
        public static readonly Aggregation MIN = new Aggregation(3, "MIN");
        public static readonly Aggregation MAX = new Aggregation(4, "MAX");
        public static readonly Aggregation COUNT = new Aggregation(5, "COUNT");
        public static readonly Aggregation MAJORITY = new Aggregation(6, "MAJORITY");

        protected static Func<short, Aggregation> GetCustom;
        protected Aggregation(short value, string name) : base(value, name)
        {
        }

        protected static Aggregation GetInstance(short value, string name) => new Aggregation(value, name);
        public override string ToString() => $"Aggregation({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(Aggregation obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator Aggregation(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is Aggregation other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(Aggregation obj1, Aggregation obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(Aggregation obj1, Aggregation obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, Aggregation obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, Aggregation obj2) => !(obj1 == obj2);

        public static bool operator ==(Aggregation obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(Aggregation obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static Aggregation GetValue(short input)
        {
            switch(input)
            {
                case var value when value == UNKNOWN.Value:
                return UNKNOWN;
                case var value when value == ZERO.Value:
                return ZERO;
                case var value when value == FIRST.Value:
                return FIRST;
                case var value when value == LAST.Value:
                return LAST;
                case var value when value == MIN.Value:
                return MIN;
                case var value when value == MAX.Value:
                return MAX;
                case var value when value == COUNT.Value:
                return COUNT;
                case var value when value == MAJORITY.Value:
                return MAJORITY;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class QEParamType : GenericEnumType<short>
    {
        public static readonly QEParamType UNKNOWN = new QEParamType(-1, "UNKNOWN");
        public static readonly QEParamType Undefined = new QEParamType(0, "Undefined");
        public static readonly QEParamType NUMBER = new QEParamType(1, "NUMBER");
        public static readonly QEParamType TEXT = new QEParamType(2, "TEXT");
        public static readonly QEParamType BOOLEAN = new QEParamType(3, "BOOLEAN");
        public static readonly QEParamType TIMESTAMP = new QEParamType(4, "TIMESTAMP");
        public static readonly QEParamType RULES_OBJECT = new QEParamType(5, "RULES_OBJECT");
        public static readonly QEParamType LENGTH_SERIES = new QEParamType(6, "LENGTH_SERIES");
        public static readonly QEParamType TIME_SERIES = new QEParamType(7, "TIME_SERIES");
        public static readonly QEParamType RATING = new QEParamType(8, "RATING");

        protected static Func<short, QEParamType> GetCustom;
        protected QEParamType(short value, string name) : base(value, name)
        {
        }

        protected static QEParamType GetInstance(short value, string name) => new QEParamType(value, name);
        public override string ToString() => $"QEParamType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(QEParamType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator QEParamType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is QEParamType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(QEParamType obj1, QEParamType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(QEParamType obj1, QEParamType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, QEParamType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, QEParamType obj2) => !(obj1 == obj2);

        public static bool operator ==(QEParamType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(QEParamType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static QEParamType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == UNKNOWN.Value:
                return UNKNOWN;
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == NUMBER.Value:
                return NUMBER;
                case var value when value == TEXT.Value:
                return TEXT;
                case var value when value == BOOLEAN.Value:
                return BOOLEAN;
                case var value when value == TIMESTAMP.Value:
                return TIMESTAMP;
                case var value when value == RULES_OBJECT.Value:
                return RULES_OBJECT;
                case var value when value == LENGTH_SERIES.Value:
                return LENGTH_SERIES;
                case var value when value == TIME_SERIES.Value:
                return TIME_SERIES;
                case var value when value == RATING.Value:
                return RATING;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CuttingTip : GenericEnumType<short>
    {
        public static readonly CuttingTip None = new CuttingTip(0, "None");
        public static readonly CuttingTip Parent = new CuttingTip(1, "Parent");
        public static readonly CuttingTip Child = new CuttingTip(2, "Child");
        public static readonly CuttingTip CuttedChild = new CuttingTip(3, "CuttedChild");

        protected static Func<short, CuttingTip> GetCustom;
        protected CuttingTip(short value, string name) : base(value, name)
        {
        }

        protected static CuttingTip GetInstance(short value, string name) => new CuttingTip(value, name);
        public override string ToString() => $"CuttingTip({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CuttingTip obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CuttingTip(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CuttingTip other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CuttingTip obj1, CuttingTip obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CuttingTip obj1, CuttingTip obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CuttingTip obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CuttingTip obj2) => !(obj1 == obj2);

        public static bool operator ==(CuttingTip obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CuttingTip obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CuttingTip GetValue(short input)
        {
            switch(input)
            {
                case var value when value == None.Value:
                return None;
                case var value when value == Parent.Value:
                return Parent;
                case var value when value == Child.Value:
                return Child;
                case var value when value == CuttedChild.Value:
                return CuttedChild;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class QEDirection : GenericEnumType<short>
    {
        public static readonly QEDirection UNKNOWN = new QEDirection(-1, "UNKNOWN");
        public static readonly QEDirection Undefined = new QEDirection(0, "Undefined");
        public static readonly QEDirection INPUT = new QEDirection(1, "INPUT");
        public static readonly QEDirection OUTPUT = new QEDirection(2, "OUTPUT");
        public static readonly QEDirection INPUT_AND_OUTPUT = new QEDirection(3, "INPUT_AND_OUTPUT");

        protected static Func<short, QEDirection> GetCustom;
        protected QEDirection(short value, string name) : base(value, name)
        {
        }

        protected static QEDirection GetInstance(short value, string name) => new QEDirection(value, name);
        public override string ToString() => $"QEDirection({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(QEDirection obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator QEDirection(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is QEDirection other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(QEDirection obj1, QEDirection obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(QEDirection obj1, QEDirection obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, QEDirection obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, QEDirection obj2) => !(obj1 == obj2);

        public static bool operator ==(QEDirection obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(QEDirection obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static QEDirection GetValue(short input)
        {
            switch(input)
            {
                case var value when value == UNKNOWN.Value:
                return UNKNOWN;
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == INPUT.Value:
                return INPUT;
                case var value when value == OUTPUT.Value:
                return OUTPUT;
                case var value when value == INPUT_AND_OUTPUT.Value:
                return INPUT_AND_OUTPUT;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class GaugeDirection : GenericEnumType<short>
    {
        public static readonly GaugeDirection Undefined = new GaugeDirection(0, "Undefined");
        public static readonly GaugeDirection L2R = new GaugeDirection(1, "L2R");
        public static readonly GaugeDirection R2L = new GaugeDirection(2, "R2L");

        protected static Func<short, GaugeDirection> GetCustom;
        protected GaugeDirection(short value, string name) : base(value, name)
        {
        }

        protected static GaugeDirection GetInstance(short value, string name) => new GaugeDirection(value, name);
        public override string ToString() => $"GaugeDirection({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(GaugeDirection obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator GaugeDirection(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is GaugeDirection other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(GaugeDirection obj1, GaugeDirection obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(GaugeDirection obj1, GaugeDirection obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, GaugeDirection obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, GaugeDirection obj2) => !(obj1 == obj2);

        public static bool operator ==(GaugeDirection obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(GaugeDirection obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static GaugeDirection GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == L2R.Value:
                return L2R;
                case var value when value == R2L.Value:
                return R2L;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TypeOfScrap : GenericEnumType<short>
    {
        public static readonly TypeOfScrap None = new TypeOfScrap(0, "None");
        public static readonly TypeOfScrap PartialScrap = new TypeOfScrap(1, "PartialScrap");
        public static readonly TypeOfScrap Scrap = new TypeOfScrap(2, "Scrap");

        protected static Func<short, TypeOfScrap> GetCustom;
        protected TypeOfScrap(short value, string name) : base(value, name)
        {
        }

        protected static TypeOfScrap GetInstance(short value, string name) => new TypeOfScrap(value, name);
        public override string ToString() => $"TypeOfScrap({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TypeOfScrap obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TypeOfScrap(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TypeOfScrap other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TypeOfScrap obj1, TypeOfScrap obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TypeOfScrap obj1, TypeOfScrap obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TypeOfScrap obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TypeOfScrap obj2) => !(obj1 == obj2);

        public static bool operator ==(TypeOfScrap obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TypeOfScrap obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TypeOfScrap GetValue(short input)
        {
            switch(input)
            {
                case var value when value == None.Value:
                return None;
                case var value when value == PartialScrap.Value:
                return PartialScrap;
                case var value when value == Scrap.Value:
                return Scrap;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class MeasurementType : GenericEnumType<short>
    {
        public static readonly MeasurementType Undefined = new MeasurementType(0, "Undefined");
        public static readonly MeasurementType BIT = new MeasurementType(1, "BIT");
        public static readonly MeasurementType SHORT = new MeasurementType(2, "SHORT");
        public static readonly MeasurementType INT = new MeasurementType(3, "INT");
        public static readonly MeasurementType FLOAT = new MeasurementType(4, "FLOAT");
        public static readonly MeasurementType DOUBLE = new MeasurementType(5, "DOUBLE");
        public static readonly MeasurementType TIMESTAMP = new MeasurementType(6, "TIMESTAMP");
        public static readonly MeasurementType TEXT = new MeasurementType(7, "TEXT");
        public static readonly MeasurementType MEAS_DATA = new MeasurementType(8, "MEAS_DATA");
        public static readonly MeasurementType LONG = new MeasurementType(9, "LONG");

        protected static Func<short, MeasurementType> GetCustom;
        protected MeasurementType(short value, string name) : base(value, name)
        {
        }

        protected static MeasurementType GetInstance(short value, string name) => new MeasurementType(value, name);
        public override string ToString() => $"MeasurementType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(MeasurementType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator MeasurementType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is MeasurementType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(MeasurementType obj1, MeasurementType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(MeasurementType obj1, MeasurementType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, MeasurementType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, MeasurementType obj2) => !(obj1 == obj2);

        public static bool operator ==(MeasurementType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(MeasurementType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static MeasurementType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == BIT.Value:
                return BIT;
                case var value when value == SHORT.Value:
                return SHORT;
                case var value when value == INT.Value:
                return INT;
                case var value when value == FLOAT.Value:
                return FLOAT;
                case var value when value == DOUBLE.Value:
                return DOUBLE;
                case var value when value == TIMESTAMP.Value:
                return TIMESTAMP;
                case var value when value == TEXT.Value:
                return TEXT;
                case var value when value == MEAS_DATA.Value:
                return MEAS_DATA;
                case var value when value == LONG.Value:
                return LONG;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class Grading : GenericEnumType<short>
    {
        public static readonly Grading EvaluateFailed = new Grading(0, "EvaluateFailed");
        public static readonly Grading Optimum = new Grading(1, "Optimum");
        public static readonly Grading Normal = new Grading(2, "Normal");
        public static readonly Grading Warning = new Grading(3, "Warning");
        public static readonly Grading NotConform = new Grading(4, "NotConform");
        public static readonly Grading OutOfContro = new Grading(5, "OutOfContro");

        protected static Func<short, Grading> GetCustom;
        protected Grading(short value, string name) : base(value, name)
        {
        }

        protected static Grading GetInstance(short value, string name) => new Grading(value, name);
        public override string ToString() => $"Grading({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(Grading obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator Grading(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is Grading other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(Grading obj1, Grading obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(Grading obj1, Grading obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, Grading obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, Grading obj2) => !(obj1 == obj2);

        public static bool operator ==(Grading obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(Grading obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static Grading GetValue(short input)
        {
            switch(input)
            {
                case var value when value == EvaluateFailed.Value:
                return EvaluateFailed;
                case var value when value == Optimum.Value:
                return Optimum;
                case var value when value == Normal.Value:
                return Normal;
                case var value when value == Warning.Value:
                return Warning;
                case var value when value == NotConform.Value:
                return NotConform;
                case var value when value == OutOfContro.Value:
                return OutOfContro;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class KPITime : GenericEnumType<short>
    {
        public static readonly KPITime Undefined = new KPITime(0, "Undefined");
        public static readonly KPITime Minute = new KPITime(1, "Minute");
        public static readonly KPITime Hour = new KPITime(2, "Hour");
        public static readonly KPITime Shift = new KPITime(3, "Shift");
        public static readonly KPITime Asset = new KPITime(4, "Asset");

        protected static Func<short, KPITime> GetCustom;
        protected KPITime(short value, string name) : base(value, name)
        {
        }

        protected static KPITime GetInstance(short value, string name) => new KPITime(value, name);
        public override string ToString() => $"KPITime({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(KPITime obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator KPITime(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is KPITime other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(KPITime obj1, KPITime obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(KPITime obj1, KPITime obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, KPITime obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, KPITime obj2) => !(obj1 == obj2);

        public static bool operator ==(KPITime obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(KPITime obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static KPITime GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Minute.Value:
                return Minute;
                case var value when value == Hour.Value:
                return Hour;
                case var value when value == Shift.Value:
                return Shift;
                case var value when value == Asset.Value:
                return Asset;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RatingValue : GenericEnumType<short>
    {
        public static readonly RatingValue NAME_RatingType_Null = new RatingValue(0, "NAME_RatingType_Null");
        public static readonly RatingValue NAME_RatingType_Good = new RatingValue(1, "NAME_RatingType_Good");
        public static readonly RatingValue NAME_RatingType_Sufficient = new RatingValue(2, "NAME_RatingType_Sufficient");
        public static readonly RatingValue NAME_RatingType_Caution = new RatingValue(3, "NAME_RatingType_Caution");
        public static readonly RatingValue NAME_RatingType_Bad = new RatingValue(4, "NAME_RatingType_Bad");
        public static readonly RatingValue NAME_RatingType_Critical = new RatingValue(5, "NAME_RatingType_Critical");

        protected static Func<short, RatingValue> GetCustom;
        protected RatingValue(short value, string name) : base(value, name)
        {
        }

        protected static RatingValue GetInstance(short value, string name) => new RatingValue(value, name);
        public override string ToString() => $"RatingValue({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RatingValue obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RatingValue(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RatingValue other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RatingValue obj1, RatingValue obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RatingValue obj1, RatingValue obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RatingValue obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RatingValue obj2) => !(obj1 == obj2);

        public static bool operator ==(RatingValue obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RatingValue obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RatingValue GetValue(short input)
        {
            switch(input)
            {
                case var value when value == NAME_RatingType_Null.Value:
                return NAME_RatingType_Null;
                case var value when value == NAME_RatingType_Good.Value:
                return NAME_RatingType_Good;
                case var value when value == NAME_RatingType_Sufficient.Value:
                return NAME_RatingType_Sufficient;
                case var value when value == NAME_RatingType_Caution.Value:
                return NAME_RatingType_Caution;
                case var value when value == NAME_RatingType_Bad.Value:
                return NAME_RatingType_Bad;
                case var value when value == NAME_RatingType_Critical.Value:
                return NAME_RatingType_Critical;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class PartOfMaterialType : GenericEnumType<short>
    {
        public static readonly PartOfMaterialType HeadPart = new PartOfMaterialType(0, "HeadPart");
        public static readonly PartOfMaterialType MaterialPart = new PartOfMaterialType(1, "MaterialPart");
        public static readonly PartOfMaterialType TailPart = new PartOfMaterialType(2, "TailPart");

        protected static Func<short, PartOfMaterialType> GetCustom;
        protected PartOfMaterialType(short value, string name) : base(value, name)
        {
        }

        protected static PartOfMaterialType GetInstance(short value, string name) => new PartOfMaterialType(value, name);
        public override string ToString() => $"PartOfMaterialType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(PartOfMaterialType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator PartOfMaterialType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is PartOfMaterialType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(PartOfMaterialType obj1, PartOfMaterialType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(PartOfMaterialType obj1, PartOfMaterialType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, PartOfMaterialType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, PartOfMaterialType obj2) => !(obj1 == obj2);

        public static bool operator ==(PartOfMaterialType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(PartOfMaterialType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static PartOfMaterialType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == HeadPart.Value:
                return HeadPart;
                case var value when value == MaterialPart.Value:
                return MaterialPart;
                case var value when value == TailPart.Value:
                return TailPart;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CommStatus : GenericEnumType<short>
    {
        public static readonly CommStatus ProcessingError = new CommStatus(-2, "ProcessingError");
        public static readonly CommStatus ValidationError = new CommStatus(-1, "ValidationError");
        public static readonly CommStatus New = new CommStatus(0, "New");
        public static readonly CommStatus BeingProcessed = new CommStatus(1, "BeingProcessed");
        public static readonly CommStatus OK = new CommStatus(2, "OK");

        protected static Func<short, CommStatus> GetCustom;
        protected CommStatus(short value, string name) : base(value, name)
        {
        }

        protected static CommStatus GetInstance(short value, string name) => new CommStatus(value, name);
        public override string ToString() => $"CommStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CommStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CommStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CommStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CommStatus obj1, CommStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CommStatus obj1, CommStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CommStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CommStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(CommStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CommStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CommStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == ProcessingError.Value:
                return ProcessingError;
                case var value when value == ValidationError.Value:
                return ValidationError;
                case var value when value == New.Value:
                return New;
                case var value when value == BeingProcessed.Value:
                return BeingProcessed;
                case var value when value == OK.Value:
                return OK;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ScheduleMoveOperator : GenericEnumType<short>
    {
        public static readonly ScheduleMoveOperator Up = new ScheduleMoveOperator(-1, "Up");
        public static readonly ScheduleMoveOperator Non = new ScheduleMoveOperator(0, "Non");
        public static readonly ScheduleMoveOperator Down = new ScheduleMoveOperator(1, "Down");

        protected static Func<short, ScheduleMoveOperator> GetCustom;
        protected ScheduleMoveOperator(short value, string name) : base(value, name)
        {
        }

        protected static ScheduleMoveOperator GetInstance(short value, string name) => new ScheduleMoveOperator(value, name);
        public override string ToString() => $"ScheduleMoveOperator({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ScheduleMoveOperator obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ScheduleMoveOperator(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ScheduleMoveOperator other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ScheduleMoveOperator obj1, ScheduleMoveOperator obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ScheduleMoveOperator obj1, ScheduleMoveOperator obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ScheduleMoveOperator obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ScheduleMoveOperator obj2) => !(obj1 == obj2);

        public static bool operator ==(ScheduleMoveOperator obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ScheduleMoveOperator obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ScheduleMoveOperator GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Up.Value:
                return Up;
                case var value when value == Non.Value:
                return Non;
                case var value when value == Down.Value:
                return Down;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class EventType : GenericEnumType<short>
    {
        public static readonly EventType Undefined = new EventType(0, "Undefined");
        public static readonly EventType LineDelay = new EventType(10, "LineDelay");
        public static readonly EventType WorkshopEvent = new EventType(20, "WorkshopEvent");
        public static readonly EventType FurnaceEvent = new EventType(30, "FurnaceEvent");
        public static readonly EventType MillEvent = new EventType(40, "MillEvent");
        public static readonly EventType MaintenanceEvent = new EventType(50, "MaintenanceEvent");
        public static readonly EventType Checkpoint1Delay = new EventType(101, "Checkpoint1Delay");
        public static readonly EventType Checkpoint1DelayMicroStop = new EventType(102, "Checkpoint1DelayMicroStop");
        public static readonly EventType WorkshopOpening = new EventType(201, "WorkshopOpening");
        public static readonly EventType WorkshopClosure = new EventType(202, "WorkshopClosure");
        public static readonly EventType Charge = new EventType(301, "Charge");
        public static readonly EventType Uncharge = new EventType(302, "Uncharge");
        public static readonly EventType Discharge = new EventType(303, "Discharge");
        public static readonly EventType Undischarge = new EventType(304, "Undischarge");
        public static readonly EventType Bypass = new EventType(305, "Bypass");
        public static readonly EventType Turnaround = new EventType(306, "Turnaround");
        public static readonly EventType OnCoolingBed = new EventType(307, "OnCoolingBed");
        public static readonly EventType OnEnterTable = new EventType(308, "OnEnterTable");
        public static readonly EventType StartSlowCadence = new EventType(401, "StartSlowCadence");
        public static readonly EventType EndSlowCadence = new EventType(402, "EndSlowCadence");
        public static readonly EventType Cobble = new EventType(403, "Cobble");
        public static readonly EventType Bonn = new EventType(404, "Bonn");
        public static readonly EventType Checkpoint1In = new EventType(405, "Checkpoint1In");
        public static readonly EventType Checkpoint1Out = new EventType(406, "Checkpoint1Out");
        public static readonly EventType FullScrap = new EventType(407, "FullScrap");
        public static readonly EventType Reject = new EventType(408, "Reject");
        public static readonly EventType PartialScrap = new EventType(409, "PartialScrap");
        public static readonly EventType ProductCreate = new EventType(410, "ProductCreate");
        public static readonly EventType OnGarret = new EventType(417, "OnGarret");

        protected static Func<short, EventType> GetCustom;
        protected EventType(short value, string name) : base(value, name)
        {
        }

        protected static EventType GetInstance(short value, string name) => new EventType(value, name);
        public override string ToString() => $"EventType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(EventType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator EventType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is EventType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(EventType obj1, EventType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(EventType obj1, EventType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, EventType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, EventType obj2) => !(obj1 == obj2);

        public static bool operator ==(EventType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(EventType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static EventType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == LineDelay.Value:
                return LineDelay;
                case var value when value == WorkshopEvent.Value:
                return WorkshopEvent;
                case var value when value == FurnaceEvent.Value:
                return FurnaceEvent;
                case var value when value == MillEvent.Value:
                return MillEvent;
                case var value when value == MaintenanceEvent.Value:
                return MaintenanceEvent;
                case var value when value == Checkpoint1Delay.Value:
                return Checkpoint1Delay;
                case var value when value == Checkpoint1DelayMicroStop.Value:
                return Checkpoint1DelayMicroStop;
                case var value when value == WorkshopOpening.Value:
                return WorkshopOpening;
                case var value when value == WorkshopClosure.Value:
                return WorkshopClosure;
                case var value when value == Charge.Value:
                return Charge;
                case var value when value == Uncharge.Value:
                return Uncharge;
                case var value when value == Discharge.Value:
                return Discharge;
                case var value when value == Undischarge.Value:
                return Undischarge;
                case var value when value == Bypass.Value:
                return Bypass;
                case var value when value == Turnaround.Value:
                return Turnaround;
                case var value when value == OnCoolingBed.Value:
                return OnCoolingBed;
                case var value when value == OnEnterTable.Value:
                return OnEnterTable;
                case var value when value == StartSlowCadence.Value:
                return StartSlowCadence;
                case var value when value == EndSlowCadence.Value:
                return EndSlowCadence;
                case var value when value == Cobble.Value:
                return Cobble;
                case var value when value == Bonn.Value:
                return Bonn;
                case var value when value == Checkpoint1In.Value:
                return Checkpoint1In;
                case var value when value == Checkpoint1Out.Value:
                return Checkpoint1Out;
                case var value when value == FullScrap.Value:
                return FullScrap;
                case var value when value == Reject.Value:
                return Reject;
                case var value when value == PartialScrap.Value:
                return PartialScrap;
                case var value when value == ProductCreate.Value:
                return ProductCreate;
                case var value when value == OnGarret.Value:
                return OnGarret;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class AssetsArea : GenericEnumType<short>
    {
        public static readonly AssetsArea Charging = new AssetsArea(0, "Charging");
        public static readonly AssetsArea Furnace = new AssetsArea(1, "Furnace");
        public static readonly AssetsArea Rolling = new AssetsArea(2, "Rolling");
        public static readonly AssetsArea AfterCut = new AssetsArea(3, "AfterCut");

        protected static Func<short, AssetsArea> GetCustom;
        protected AssetsArea(short value, string name) : base(value, name)
        {
        }

        protected static AssetsArea GetInstance(short value, string name) => new AssetsArea(value, name);
        public override string ToString() => $"AssetsArea({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(AssetsArea obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator AssetsArea(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is AssetsArea other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(AssetsArea obj1, AssetsArea obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(AssetsArea obj1, AssetsArea obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, AssetsArea obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, AssetsArea obj2) => !(obj1 == obj2);

        public static bool operator ==(AssetsArea obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(AssetsArea obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static AssetsArea GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Charging.Value:
                return Charging;
                case var value when value == Furnace.Value:
                return Furnace;
                case var value when value == Rolling.Value:
                return Rolling;
                case var value when value == AfterCut.Value:
                return AfterCut;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class QESignalType : GenericEnumType<short>
    {
        public static readonly QESignalType Undefined = new QESignalType(0, "Undefined");
        public static readonly QESignalType NUMERIC = new QESignalType(1, "NUMERIC");
        public static readonly QESignalType TEXT = new QESignalType(2, "TEXT");
        public static readonly QESignalType BOOLEAN = new QESignalType(3, "BOOLEAN");
        public static readonly QESignalType TIMESTAMP = new QESignalType(4, "TIMESTAMP");
        public static readonly QESignalType JSON_OBJECT = new QESignalType(5, "JSON_OBJECT");
        public static readonly QESignalType RATING = new QESignalType(6, "RATING");

        protected static Func<short, QESignalType> GetCustom;
        protected QESignalType(short value, string name) : base(value, name)
        {
        }

        protected static QESignalType GetInstance(short value, string name) => new QESignalType(value, name);
        public override string ToString() => $"QESignalType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(QESignalType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator QESignalType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is QESignalType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(QESignalType obj1, QESignalType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(QESignalType obj1, QESignalType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, QESignalType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, QESignalType obj2) => !(obj1 == obj2);

        public static bool operator ==(QESignalType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(QESignalType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static QESignalType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == NUMERIC.Value:
                return NUMERIC;
                case var value when value == TEXT.Value:
                return TEXT;
                case var value when value == BOOLEAN.Value:
                return BOOLEAN;
                case var value when value == TIMESTAMP.Value:
                return TIMESTAMP;
                case var value when value == JSON_OBJECT.Value:
                return JSON_OBJECT;
                case var value when value == RATING.Value:
                return RATING;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RollScrapReason : GenericEnumType<short>
    {
        public static readonly RollScrapReason Other = new RollScrapReason(0, "Other");
        public static readonly RollScrapReason Used = new RollScrapReason(1, "Used");
        public static readonly RollScrapReason Broken = new RollScrapReason(2, "Broken");
        public static readonly RollScrapReason DamagedChock = new RollScrapReason(3, "DamagedChock");

        protected static Func<short, RollScrapReason> GetCustom;
        protected RollScrapReason(short value, string name) : base(value, name)
        {
        }

        protected static RollScrapReason GetInstance(short value, string name) => new RollScrapReason(value, name);
        public override string ToString() => $"RollScrapReason({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RollScrapReason obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RollScrapReason(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RollScrapReason other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RollScrapReason obj1, RollScrapReason obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RollScrapReason obj1, RollScrapReason obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RollScrapReason obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RollScrapReason obj2) => !(obj1 == obj2);

        public static bool operator ==(RollScrapReason obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RollScrapReason obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RollScrapReason GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Other.Value:
                return Other;
                case var value when value == Used.Value:
                return Used;
                case var value when value == Broken.Value:
                return Broken;
                case var value when value == DamagedChock.Value:
                return DamagedChock;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RollStatus : GenericEnumType<short>
    {
        public static readonly RollStatus Undefined = new RollStatus(0, "Undefined");
        public static readonly RollStatus New = new RollStatus(1, "New");
        public static readonly RollStatus InRollSet = new RollStatus(2, "InRollSet");
        public static readonly RollStatus Unassigned = new RollStatus(3, "Unassigned");
        public static readonly RollStatus NotAvailable = new RollStatus(4, "NotAvailable");
        public static readonly RollStatus Turning = new RollStatus(5, "Turning");
        public static readonly RollStatus Scrapped = new RollStatus(6, "Scrapped");
        public static readonly RollStatus SchedulledForRollset = new RollStatus(7, "SchedulledForRollset");

        protected static Func<short, RollStatus> GetCustom;
        protected RollStatus(short value, string name) : base(value, name)
        {
        }

        protected static RollStatus GetInstance(short value, string name) => new RollStatus(value, name);
        public override string ToString() => $"RollStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RollStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RollStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RollStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RollStatus obj1, RollStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RollStatus obj1, RollStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RollStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RollStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(RollStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RollStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RollStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == New.Value:
                return New;
                case var value when value == InRollSet.Value:
                return InRollSet;
                case var value when value == Unassigned.Value:
                return Unassigned;
                case var value when value == NotAvailable.Value:
                return NotAvailable;
                case var value when value == Turning.Value:
                return Turning;
                case var value when value == Scrapped.Value:
                return Scrapped;
                case var value when value == SchedulledForRollset.Value:
                return SchedulledForRollset;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RollSetStatus : GenericEnumType<short>
    {
        public static readonly RollSetStatus Undefined = new RollSetStatus(0, "Undefined");
        public static readonly RollSetStatus Empty = new RollSetStatus(1, "Empty");
        public static readonly RollSetStatus Turning = new RollSetStatus(2, "Turning");
        public static readonly RollSetStatus Ready = new RollSetStatus(3, "Ready");
        public static readonly RollSetStatus ScheduledForCassette = new RollSetStatus(4, "ScheduledForCassette");
        public static readonly RollSetStatus ReadyForMounting = new RollSetStatus(5, "ReadyForMounting");
        public static readonly RollSetStatus Mounted = new RollSetStatus(6, "Mounted");
        public static readonly RollSetStatus Dismounted = new RollSetStatus(7, "Dismounted");
        public static readonly RollSetStatus NotAvailable = new RollSetStatus(8, "NotAvailable");
        public static readonly RollSetStatus ScheduledForAssemble = new RollSetStatus(9, "ScheduledForAssemble");

        protected static Func<short, RollSetStatus> GetCustom;
        protected RollSetStatus(short value, string name) : base(value, name)
        {
        }

        protected static RollSetStatus GetInstance(short value, string name) => new RollSetStatus(value, name);
        public override string ToString() => $"RollSetStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RollSetStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RollSetStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RollSetStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RollSetStatus obj1, RollSetStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RollSetStatus obj1, RollSetStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RollSetStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RollSetStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(RollSetStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RollSetStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RollSetStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Empty.Value:
                return Empty;
                case var value when value == Turning.Value:
                return Turning;
                case var value when value == Ready.Value:
                return Ready;
                case var value when value == ScheduledForCassette.Value:
                return ScheduledForCassette;
                case var value when value == ReadyForMounting.Value:
                return ReadyForMounting;
                case var value when value == Mounted.Value:
                return Mounted;
                case var value when value == Dismounted.Value:
                return Dismounted;
                case var value when value == NotAvailable.Value:
                return NotAvailable;
                case var value when value == ScheduledForAssemble.Value:
                return ScheduledForAssemble;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RollSetHistoryStatus : GenericEnumType<short>
    {
        public static readonly RollSetHistoryStatus Undefined = new RollSetHistoryStatus(0, "Undefined");
        public static readonly RollSetHistoryStatus Actual = new RollSetHistoryStatus(1, "Actual");
        public static readonly RollSetHistoryStatus Old = new RollSetHistoryStatus(2, "Old");
        public static readonly RollSetHistoryStatus Planned = new RollSetHistoryStatus(3, "Planned");

        protected static Func<short, RollSetHistoryStatus> GetCustom;
        protected RollSetHistoryStatus(short value, string name) : base(value, name)
        {
        }

        protected static RollSetHistoryStatus GetInstance(short value, string name) => new RollSetHistoryStatus(value, name);
        public override string ToString() => $"RollSetHistoryStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RollSetHistoryStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RollSetHistoryStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RollSetHistoryStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RollSetHistoryStatus obj1, RollSetHistoryStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RollSetHistoryStatus obj1, RollSetHistoryStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RollSetHistoryStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RollSetHistoryStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(RollSetHistoryStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RollSetHistoryStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RollSetHistoryStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Actual.Value:
                return Actual;
                case var value when value == Old.Value:
                return Old;
                case var value when value == Planned.Value:
                return Planned;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class GrindingTurningAction : GenericEnumType<short>
    {
        public static readonly GrindingTurningAction Undefined = new GrindingTurningAction(0, "Undefined");
        public static readonly GrindingTurningAction Plan = new GrindingTurningAction(1, "Plan");
        public static readonly GrindingTurningAction Confirm = new GrindingTurningAction(2, "Confirm");
        public static readonly GrindingTurningAction Cancel = new GrindingTurningAction(3, "Cancel");

        protected static Func<short, GrindingTurningAction> GetCustom;
        protected GrindingTurningAction(short value, string name) : base(value, name)
        {
        }

        protected static GrindingTurningAction GetInstance(short value, string name) => new GrindingTurningAction(value, name);
        public override string ToString() => $"GrindingTurningAction({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(GrindingTurningAction obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator GrindingTurningAction(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is GrindingTurningAction other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(GrindingTurningAction obj1, GrindingTurningAction obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(GrindingTurningAction obj1, GrindingTurningAction obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, GrindingTurningAction obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, GrindingTurningAction obj2) => !(obj1 == obj2);

        public static bool operator ==(GrindingTurningAction obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(GrindingTurningAction obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static GrindingTurningAction GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Plan.Value:
                return Plan;
                case var value when value == Confirm.Value:
                return Confirm;
                case var value when value == Cancel.Value:
                return Cancel;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RollSetType : GenericEnumType<short>
    {
        public static readonly RollSetType Undefined = new RollSetType(0, "Undefined");
        public static readonly RollSetType RMRollSet = new RollSetType(1, "RMRollSet");
        public static readonly RollSetType IMRollSet = new RollSetType(2, "IMRollSet");
        public static readonly RollSetType FMRollSet = new RollSetType(3, "FMRollSet");

        protected static Func<short, RollSetType> GetCustom;
        protected RollSetType(short value, string name) : base(value, name)
        {
        }

        protected static RollSetType GetInstance(short value, string name) => new RollSetType(value, name);
        public override string ToString() => $"RollSetType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RollSetType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RollSetType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RollSetType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RollSetType obj1, RollSetType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RollSetType obj1, RollSetType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RollSetType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RollSetType obj2) => !(obj1 == obj2);

        public static bool operator ==(RollSetType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RollSetType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RollSetType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == RMRollSet.Value:
                return RMRollSet;
                case var value when value == IMRollSet.Value:
                return IMRollSet;
                case var value when value == FMRollSet.Value:
                return FMRollSet;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RollGrooveStatus : GenericEnumType<short>
    {
        public static readonly RollGrooveStatus Undefined = new RollGrooveStatus(0, "Undefined");
        public static readonly RollGrooveStatus Actual = new RollGrooveStatus(1, "Actual");
        public static readonly RollGrooveStatus Active = new RollGrooveStatus(2, "Active");
        public static readonly RollGrooveStatus Old = new RollGrooveStatus(3, "Old");
        public static readonly RollGrooveStatus PlannedAndNoChange = new RollGrooveStatus(4, "PlannedAndNoChange");
        public static readonly RollGrooveStatus PlannedAndTurning = new RollGrooveStatus(5, "PlannedAndTurning");
        public static readonly RollGrooveStatus PlannedAndNotAvailable = new RollGrooveStatus(6, "PlannedAndNotAvailable");
        public static readonly RollGrooveStatus NotAvailable = new RollGrooveStatus(7, "NotAvailable");

        protected static Func<short, RollGrooveStatus> GetCustom;
        protected RollGrooveStatus(short value, string name) : base(value, name)
        {
        }

        protected static RollGrooveStatus GetInstance(short value, string name) => new RollGrooveStatus(value, name);
        public override string ToString() => $"RollGrooveStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RollGrooveStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RollGrooveStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RollGrooveStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RollGrooveStatus obj1, RollGrooveStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RollGrooveStatus obj1, RollGrooveStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RollGrooveStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RollGrooveStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(RollGrooveStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RollGrooveStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RollGrooveStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Actual.Value:
                return Actual;
                case var value when value == Active.Value:
                return Active;
                case var value when value == Old.Value:
                return Old;
                case var value when value == PlannedAndNoChange.Value:
                return PlannedAndNoChange;
                case var value when value == PlannedAndTurning.Value:
                return PlannedAndTurning;
                case var value when value == PlannedAndNotAvailable.Value:
                return PlannedAndNotAvailable;
                case var value when value == NotAvailable.Value:
                return NotAvailable;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CassetteStatus : GenericEnumType<short>
    {
        public static readonly CassetteStatus Undefined = new CassetteStatus(0, "Undefined");
        public static readonly CassetteStatus New = new CassetteStatus(1, "New");
        public static readonly CassetteStatus Empty = new CassetteStatus(2, "Empty");
        public static readonly CassetteStatus RollSetInside = new CassetteStatus(3, "RollSetInside");
        public static readonly CassetteStatus MountedInStand = new CassetteStatus(4, "MountedInStand");
        public static readonly CassetteStatus InRegeneration = new CassetteStatus(5, "InRegeneration");
        public static readonly CassetteStatus NotAvailable = new CassetteStatus(6, "NotAvailable");
        public static readonly CassetteStatus AssembleIncomplete = new CassetteStatus(7, "AssembleIncomplete");
        public static readonly CassetteStatus NoStatus = new CassetteStatus(8, "NoStatus");
        public static readonly CassetteStatus ScheduledForAssemble = new CassetteStatus(9, "ScheduledForAssemble");
        public static readonly CassetteStatus MountedInCasette = new CassetteStatus(10, "MountedInCasette");
        public static readonly CassetteStatus ReadyForMountingWithRollSet = new CassetteStatus(11, "ReadyForMountingWithRollSet");
        public static readonly CassetteStatus ForStore = new CassetteStatus(12, "ForStore");
        public static readonly CassetteStatus History = new CassetteStatus(99, "History");

        protected static Func<short, CassetteStatus> GetCustom;
        protected CassetteStatus(short value, string name) : base(value, name)
        {
        }

        protected static CassetteStatus GetInstance(short value, string name) => new CassetteStatus(value, name);
        public override string ToString() => $"CassetteStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CassetteStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CassetteStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CassetteStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CassetteStatus obj1, CassetteStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CassetteStatus obj1, CassetteStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CassetteStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CassetteStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(CassetteStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CassetteStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CassetteStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == New.Value:
                return New;
                case var value when value == Empty.Value:
                return Empty;
                case var value when value == RollSetInside.Value:
                return RollSetInside;
                case var value when value == MountedInStand.Value:
                return MountedInStand;
                case var value when value == InRegeneration.Value:
                return InRegeneration;
                case var value when value == NotAvailable.Value:
                return NotAvailable;
                case var value when value == AssembleIncomplete.Value:
                return AssembleIncomplete;
                case var value when value == NoStatus.Value:
                return NoStatus;
                case var value when value == ScheduledForAssemble.Value:
                return ScheduledForAssemble;
                case var value when value == MountedInCasette.Value:
                return MountedInCasette;
                case var value when value == ReadyForMountingWithRollSet.Value:
                return ReadyForMountingWithRollSet;
                case var value when value == ForStore.Value:
                return ForStore;
                case var value when value == History.Value:
                return History;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CassetteArrangement : GenericEnumType<short>
    {
        public static readonly CassetteArrangement Undefined = new CassetteArrangement(0, "Undefined");
        public static readonly CassetteArrangement Horizontal = new CassetteArrangement(1, "Horizontal");
        public static readonly CassetteArrangement Vertical = new CassetteArrangement(2, "Vertical");
        public static readonly CassetteArrangement Other = new CassetteArrangement(3, "Other");

        protected static Func<short, CassetteArrangement> GetCustom;
        protected CassetteArrangement(short value, string name) : base(value, name)
        {
        }

        protected static CassetteArrangement GetInstance(short value, string name) => new CassetteArrangement(value, name);
        public override string ToString() => $"CassetteArrangement({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CassetteArrangement obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CassetteArrangement(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CassetteArrangement other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CassetteArrangement obj1, CassetteArrangement obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CassetteArrangement obj1, CassetteArrangement obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CassetteArrangement obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CassetteArrangement obj2) => !(obj1 == obj2);

        public static bool operator ==(CassetteArrangement obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CassetteArrangement obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CassetteArrangement GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Horizontal.Value:
                return Horizontal;
                case var value when value == Vertical.Value:
                return Vertical;
                case var value when value == Other.Value:
                return Other;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CassetteType : GenericEnumType<short>
    {
        public static readonly CassetteType RMCassette = new CassetteType(0, "RMCassette");
        public static readonly CassetteType IMCassette = new CassetteType(1, "IMCassette");
        public static readonly CassetteType FMCassette = new CassetteType(2, "FMCassette");

        protected static Func<short, CassetteType> GetCustom;
        protected CassetteType(short value, string name) : base(value, name)
        {
        }

        protected static CassetteType GetInstance(short value, string name) => new CassetteType(value, name);
        public override string ToString() => $"CassetteType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CassetteType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CassetteType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CassetteType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CassetteType obj1, CassetteType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CassetteType obj1, CassetteType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CassetteType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CassetteType obj2) => !(obj1 == obj2);

        public static bool operator ==(CassetteType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CassetteType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CassetteType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == RMCassette.Value:
                return RMCassette;
                case var value when value == IMCassette.Value:
                return IMCassette;
                case var value when value == FMCassette.Value:
                return FMCassette;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RollSetCassetteAction : GenericEnumType<short>
    {
        public static readonly RollSetCassetteAction Undefined = new RollSetCassetteAction(0, "Undefined");
        public static readonly RollSetCassetteAction PlanRollSet = new RollSetCassetteAction(1, "PlanRollSet");
        public static readonly RollSetCassetteAction CancelPlan = new RollSetCassetteAction(2, "CancelPlan");
        public static readonly RollSetCassetteAction ConfirmRollSet = new RollSetCassetteAction(3, "ConfirmRollSet");
        public static readonly RollSetCassetteAction RemoveRollSet = new RollSetCassetteAction(4, "RemoveRollSet");

        protected static Func<short, RollSetCassetteAction> GetCustom;
        protected RollSetCassetteAction(short value, string name) : base(value, name)
        {
        }

        protected static RollSetCassetteAction GetInstance(short value, string name) => new RollSetCassetteAction(value, name);
        public override string ToString() => $"RollSetCassetteAction({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RollSetCassetteAction obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RollSetCassetteAction(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RollSetCassetteAction other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RollSetCassetteAction obj1, RollSetCassetteAction obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RollSetCassetteAction obj1, RollSetCassetteAction obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RollSetCassetteAction obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RollSetCassetteAction obj2) => !(obj1 == obj2);

        public static bool operator ==(RollSetCassetteAction obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RollSetCassetteAction obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RollSetCassetteAction GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == PlanRollSet.Value:
                return PlanRollSet;
                case var value when value == CancelPlan.Value:
                return CancelPlan;
                case var value when value == ConfirmRollSet.Value:
                return ConfirmRollSet;
                case var value when value == RemoveRollSet.Value:
                return RemoveRollSet;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class QEEvalExecutionStatus : GenericEnumType<short>
    {
        public static readonly QEEvalExecutionStatus Undefined = new QEEvalExecutionStatus(0, "Undefined");
        public static readonly QEEvalExecutionStatus SUCCESS = new QEEvalExecutionStatus(1, "SUCCESS");
        public static readonly QEEvalExecutionStatus FAILED = new QEEvalExecutionStatus(2, "FAILED");

        protected static Func<short, QEEvalExecutionStatus> GetCustom;
        protected QEEvalExecutionStatus(short value, string name) : base(value, name)
        {
        }

        protected static QEEvalExecutionStatus GetInstance(short value, string name) => new QEEvalExecutionStatus(value, name);
        public override string ToString() => $"QEEvalExecutionStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(QEEvalExecutionStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator QEEvalExecutionStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is QEEvalExecutionStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(QEEvalExecutionStatus obj1, QEEvalExecutionStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(QEEvalExecutionStatus obj1, QEEvalExecutionStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, QEEvalExecutionStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, QEEvalExecutionStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(QEEvalExecutionStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(QEEvalExecutionStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static QEEvalExecutionStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == SUCCESS.Value:
                return SUCCESS;
                case var value when value == FAILED.Value:
                return FAILED;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class GradingSource : GenericEnumType<short>
    {
        public static readonly GradingSource Undefined = new GradingSource(0, "Undefined");
        public static readonly GradingSource CalculatedValue = new GradingSource(1, "CalculatedValue");
        public static readonly GradingSource ForcedValue = new GradingSource(2, "ForcedValue");
        public static readonly GradingSource Alternative = new GradingSource(3, "Alternative");

        protected static Func<short, GradingSource> GetCustom;
        protected GradingSource(short value, string name) : base(value, name)
        {
        }

        protected static GradingSource GetInstance(short value, string name) => new GradingSource(value, name);
        public override string ToString() => $"GradingSource({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(GradingSource obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator GradingSource(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is GradingSource other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(GradingSource obj1, GradingSource obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(GradingSource obj1, GradingSource obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, GradingSource obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, GradingSource obj2) => !(obj1 == obj2);

        public static bool operator ==(GradingSource obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(GradingSource obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static GradingSource GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == CalculatedValue.Value:
                return CalculatedValue;
                case var value when value == ForcedValue.Value:
                return ForcedValue;
                case var value when value == Alternative.Value:
                return Alternative;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class StandStatus : GenericEnumType<short>
    {
        public static readonly StandStatus Undefined = new StandStatus(0, "Undefined");
        public static readonly StandStatus Active = new StandStatus(1, "Active");
        public static readonly StandStatus Inactive = new StandStatus(2, "Inactive");

        protected static Func<short, StandStatus> GetCustom;
        protected StandStatus(short value, string name) : base(value, name)
        {
        }

        protected static StandStatus GetInstance(short value, string name) => new StandStatus(value, name);
        public override string ToString() => $"StandStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(StandStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator StandStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is StandStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(StandStatus obj1, StandStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(StandStatus obj1, StandStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, StandStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, StandStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(StandStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(StandStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static StandStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Active.Value:
                return Active;
                case var value when value == Inactive.Value:
                return Inactive;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class RollChangeAction : GenericEnumType<short>
    {
        public static readonly RollChangeAction Undefined = new RollChangeAction(0, "Undefined");
        public static readonly RollChangeAction SwapCassette = new RollChangeAction(1, "SwapCassette");
        public static readonly RollChangeAction SwapRollSetOnly = new RollChangeAction(2, "SwapRollSetOnly");
        public static readonly RollChangeAction DismountWithCassette = new RollChangeAction(3, "DismountWithCassette");
        public static readonly RollChangeAction DismountRollSetOnly = new RollChangeAction(4, "DismountRollSetOnly");
        public static readonly RollChangeAction MountWithCassette = new RollChangeAction(5, "MountWithCassette");
        public static readonly RollChangeAction MountRollSetOnly = new RollChangeAction(6, "MountRollSetOnly");
        public static readonly RollChangeAction Edit = new RollChangeAction(7, "Edit");

        protected static Func<short, RollChangeAction> GetCustom;
        protected RollChangeAction(short value, string name) : base(value, name)
        {
        }

        protected static RollChangeAction GetInstance(short value, string name) => new RollChangeAction(value, name);
        public override string ToString() => $"RollChangeAction({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(RollChangeAction obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator RollChangeAction(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is RollChangeAction other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(RollChangeAction obj1, RollChangeAction obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(RollChangeAction obj1, RollChangeAction obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, RollChangeAction obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, RollChangeAction obj2) => !(obj1 == obj2);

        public static bool operator ==(RollChangeAction obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(RollChangeAction obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static RollChangeAction GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == SwapCassette.Value:
                return SwapCassette;
                case var value when value == SwapRollSetOnly.Value:
                return SwapRollSetOnly;
                case var value when value == DismountWithCassette.Value:
                return DismountWithCassette;
                case var value when value == DismountRollSetOnly.Value:
                return DismountRollSetOnly;
                case var value when value == MountWithCassette.Value:
                return MountWithCassette;
                case var value when value == MountRollSetOnly.Value:
                return MountRollSetOnly;
                case var value when value == Edit.Value:
                return Edit;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class StandActivity : GenericEnumType<short>
    {
        public static readonly StandActivity Offline = new StandActivity(0, "Offline");
        public static readonly StandActivity Online = new StandActivity(1, "Online");

        protected static Func<short, StandActivity> GetCustom;
        protected StandActivity(short value, string name) : base(value, name)
        {
        }

        protected static StandActivity GetInstance(short value, string name) => new StandActivity(value, name);
        public override string ToString() => $"StandActivity({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(StandActivity obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator StandActivity(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is StandActivity other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(StandActivity obj1, StandActivity obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(StandActivity obj1, StandActivity obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, StandActivity obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, StandActivity obj2) => !(obj1 == obj2);

        public static bool operator ==(StandActivity obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(StandActivity obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static StandActivity GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Offline.Value:
                return Offline;
                case var value when value == Online.Value:
                return Online;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TrackingVisualizationAction : GenericEnumType<short>
    {
        public static readonly TrackingVisualizationAction HeadForward = new TrackingVisualizationAction(0, "HeadForward");
        public static readonly TrackingVisualizationAction TailForward = new TrackingVisualizationAction(1, "TailForward");
        public static readonly TrackingVisualizationAction MaterialReady = new TrackingVisualizationAction(2, "MaterialReady");
        public static readonly TrackingVisualizationAction RemoveFromTracking = new TrackingVisualizationAction(3, "RemoveFromTracking");
        public static readonly TrackingVisualizationAction Scrap = new TrackingVisualizationAction(4, "Scrap");
        public static readonly TrackingVisualizationAction Unscrap = new TrackingVisualizationAction(5, "Unscrap");
        public static readonly TrackingVisualizationAction PartialScrap = new TrackingVisualizationAction(6, "PartialScrap");

        protected static Func<short, TrackingVisualizationAction> GetCustom;
        protected TrackingVisualizationAction(short value, string name) : base(value, name)
        {
        }

        protected static TrackingVisualizationAction GetInstance(short value, string name) => new TrackingVisualizationAction(value, name);
        public override string ToString() => $"TrackingVisualizationAction({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TrackingVisualizationAction obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TrackingVisualizationAction(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TrackingVisualizationAction other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TrackingVisualizationAction obj1, TrackingVisualizationAction obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TrackingVisualizationAction obj1, TrackingVisualizationAction obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TrackingVisualizationAction obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TrackingVisualizationAction obj2) => !(obj1 == obj2);

        public static bool operator ==(TrackingVisualizationAction obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TrackingVisualizationAction obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TrackingVisualizationAction GetValue(short input)
        {
            switch(input)
            {
                case var value when value == HeadForward.Value:
                return HeadForward;
                case var value when value == TailForward.Value:
                return TailForward;
                case var value when value == MaterialReady.Value:
                return MaterialReady;
                case var value when value == RemoveFromTracking.Value:
                return RemoveFromTracking;
                case var value when value == Scrap.Value:
                return Scrap;
                case var value when value == Unscrap.Value:
                return Unscrap;
                case var value when value == PartialScrap.Value:
                return PartialScrap;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TrackingEventType : GenericEnumType<short>
    {
        public static readonly TrackingEventType Undefined = new TrackingEventType(0, "Undefined");
        public static readonly TrackingEventType Enter = new TrackingEventType(1, "Enter");
        public static readonly TrackingEventType Exit = new TrackingEventType(2, "Exit");
        public static readonly TrackingEventType UnEnter = new TrackingEventType(3, "UnEnter");
        public static readonly TrackingEventType UnExit = new TrackingEventType(4, "UnExit");

        protected static Func<short, TrackingEventType> GetCustom;
        protected TrackingEventType(short value, string name) : base(value, name)
        {
        }

        protected static TrackingEventType GetInstance(short value, string name) => new TrackingEventType(value, name);
        public override string ToString() => $"TrackingEventType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TrackingEventType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TrackingEventType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TrackingEventType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TrackingEventType obj1, TrackingEventType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TrackingEventType obj1, TrackingEventType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TrackingEventType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TrackingEventType obj2) => !(obj1 == obj2);

        public static bool operator ==(TrackingEventType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TrackingEventType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TrackingEventType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Enter.Value:
                return Enter;
                case var value when value == Exit.Value:
                return Exit;
                case var value when value == UnEnter.Value:
                return UnEnter;
                case var value when value == UnExit.Value:
                return UnExit;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class AssignmentType : GenericEnumType<short>
    {
        public static readonly AssignmentType Assigned = new AssignmentType(0, "Assigned");
        public static readonly AssignmentType Distributed = new AssignmentType(1, "Distributed");

        protected static Func<short, AssignmentType> GetCustom;
        protected AssignmentType(short value, string name) : base(value, name)
        {
        }

        protected static AssignmentType GetInstance(short value, string name) => new AssignmentType(value, name);
        public override string ToString() => $"AssignmentType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(AssignmentType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator AssignmentType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is AssignmentType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(AssignmentType obj1, AssignmentType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(AssignmentType obj1, AssignmentType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, AssignmentType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, AssignmentType obj2) => !(obj1 == obj2);

        public static bool operator ==(AssignmentType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(AssignmentType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static AssignmentType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Assigned.Value:
                return Assigned;
                case var value when value == Distributed.Value:
                return Distributed;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ParentMillEventType : GenericEnumType<short>
    {
        public static readonly ParentMillEventType LineDelay = new ParentMillEventType(10, "LineDelay");
        public static readonly ParentMillEventType WorkshopEvent = new ParentMillEventType(20, "WorkshopEvent");
        public static readonly ParentMillEventType FurnaceEvent = new ParentMillEventType(30, "FurnaceEvent");
        public static readonly ParentMillEventType MillEvent = new ParentMillEventType(40, "MillEvent");
        public static readonly ParentMillEventType MaintenanceEvent = new ParentMillEventType(50, "MaintenanceEvent");

        protected static Func<short, ParentMillEventType> GetCustom;
        protected ParentMillEventType(short value, string name) : base(value, name)
        {
        }

        protected static ParentMillEventType GetInstance(short value, string name) => new ParentMillEventType(value, name);
        public override string ToString() => $"ParentMillEventType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ParentMillEventType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ParentMillEventType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ParentMillEventType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ParentMillEventType obj1, ParentMillEventType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ParentMillEventType obj1, ParentMillEventType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ParentMillEventType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ParentMillEventType obj2) => !(obj1 == obj2);

        public static bool operator ==(ParentMillEventType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ParentMillEventType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ParentMillEventType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == LineDelay.Value:
                return LineDelay;
                case var value when value == WorkshopEvent.Value:
                return WorkshopEvent;
                case var value when value == FurnaceEvent.Value:
                return FurnaceEvent;
                case var value when value == MillEvent.Value:
                return MillEvent;
                case var value when value == MaintenanceEvent.Value:
                return MaintenanceEvent;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class AreaType : GenericEnumType<short>
    {
        public static readonly AreaType Undefined = new AreaType(0, "Undefined");

        protected static Func<short, AreaType> GetCustom;
        protected AreaType(short value, string name) : base(value, name)
        {
        }

        protected static AreaType GetInstance(short value, string name) => new AreaType(value, name);
        public override string ToString() => $"AreaType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(AreaType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator AreaType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is AreaType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(AreaType obj1, AreaType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(AreaType obj1, AreaType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, AreaType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, AreaType obj2) => !(obj1 == obj2);

        public static bool operator ==(AreaType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(AreaType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static AreaType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ChildMillEventType : GenericEnumType<short>
    {
        public static readonly ChildMillEventType Checkpoint1Delay = new ChildMillEventType(101, "Checkpoint1Delay");
        public static readonly ChildMillEventType Checkpoint1DelayMicroStop = new ChildMillEventType(102, "Checkpoint1DelayMicroStop");
        public static readonly ChildMillEventType WorkshopOpening = new ChildMillEventType(201, "WorkshopOpening");
        public static readonly ChildMillEventType WorkshopClosure = new ChildMillEventType(202, "WorkshopClosure");
        public static readonly ChildMillEventType Charge = new ChildMillEventType(301, "Charge");
        public static readonly ChildMillEventType Uncharge = new ChildMillEventType(302, "Uncharge");
        public static readonly ChildMillEventType Discharge = new ChildMillEventType(303, "Discharge");
        public static readonly ChildMillEventType Undischarge = new ChildMillEventType(304, "Undischarge");
        public static readonly ChildMillEventType Bypass = new ChildMillEventType(305, "Bypass");
        public static readonly ChildMillEventType Turnaround = new ChildMillEventType(306, "Turnaround");
        public static readonly ChildMillEventType StartSlowCadence = new ChildMillEventType(401, "StartSlowCadence");
        public static readonly ChildMillEventType EndSlowCadence = new ChildMillEventType(402, "EndSlowCadence");
        public static readonly ChildMillEventType Cobble = new ChildMillEventType(403, "Cobble");
        public static readonly ChildMillEventType MaterialReady = new ChildMillEventType(404, "MaterialReady");
        public static readonly ChildMillEventType Checkpoint1In = new ChildMillEventType(405, "Checkpoint1In");
        public static readonly ChildMillEventType Checkpoint1Out = new ChildMillEventType(406, "Checkpoint1Out");
        public static readonly ChildMillEventType FullScrap = new ChildMillEventType(407, "FullScrap");
        public static readonly ChildMillEventType Reject = new ChildMillEventType(408, "Reject");
        public static readonly ChildMillEventType PartialScrap = new ChildMillEventType(409, "PartialScrap");
        public static readonly ChildMillEventType ProductCreate = new ChildMillEventType(410, "ProductCreate");
        public static readonly ChildMillEventType OnGarret = new ChildMillEventType(417, "OnGarret");
        public static readonly ChildMillEventType WorkOrderStart = new ChildMillEventType(418, "WorkOrderStart");
        public static readonly ChildMillEventType WorkOrderEnd = new ChildMillEventType(419, "WorkOrderEnd");
        public static readonly ChildMillEventType ShiftOpening = new ChildMillEventType(420, "ShiftOpening");
        public static readonly ChildMillEventType ShiftClosure = new ChildMillEventType(421, "ShiftClosure");
        public static readonly ChildMillEventType UnscrapMaterial = new ChildMillEventType(422, "UnscrapMaterial");
        public static readonly ChildMillEventType RemoveFromTracking = new ChildMillEventType(423, "RemoveFromTracking");

        protected static Func<short, ChildMillEventType> GetCustom;
        protected ChildMillEventType(short value, string name) : base(value, name)
        {
        }

        protected static ChildMillEventType GetInstance(short value, string name) => new ChildMillEventType(value, name);
        public override string ToString() => $"ChildMillEventType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ChildMillEventType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ChildMillEventType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ChildMillEventType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ChildMillEventType obj1, ChildMillEventType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ChildMillEventType obj1, ChildMillEventType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ChildMillEventType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ChildMillEventType obj2) => !(obj1 == obj2);

        public static bool operator ==(ChildMillEventType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ChildMillEventType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ChildMillEventType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Checkpoint1Delay.Value:
                return Checkpoint1Delay;
                case var value when value == Checkpoint1DelayMicroStop.Value:
                return Checkpoint1DelayMicroStop;
                case var value when value == WorkshopOpening.Value:
                return WorkshopOpening;
                case var value when value == WorkshopClosure.Value:
                return WorkshopClosure;
                case var value when value == Charge.Value:
                return Charge;
                case var value when value == Uncharge.Value:
                return Uncharge;
                case var value when value == Discharge.Value:
                return Discharge;
                case var value when value == Undischarge.Value:
                return Undischarge;
                case var value when value == Bypass.Value:
                return Bypass;
                case var value when value == Turnaround.Value:
                return Turnaround;
                case var value when value == StartSlowCadence.Value:
                return StartSlowCadence;
                case var value when value == EndSlowCadence.Value:
                return EndSlowCadence;
                case var value when value == Cobble.Value:
                return Cobble;
                case var value when value == MaterialReady.Value:
                return MaterialReady;
                case var value when value == Checkpoint1In.Value:
                return Checkpoint1In;
                case var value when value == Checkpoint1Out.Value:
                return Checkpoint1Out;
                case var value when value == FullScrap.Value:
                return FullScrap;
                case var value when value == Reject.Value:
                return Reject;
                case var value when value == PartialScrap.Value:
                return PartialScrap;
                case var value when value == ProductCreate.Value:
                return ProductCreate;
                case var value when value == OnGarret.Value:
                return OnGarret;
                case var value when value == WorkOrderStart.Value:
                return WorkOrderStart;
                case var value when value == WorkOrderEnd.Value:
                return WorkOrderEnd;
                case var value when value == ShiftOpening.Value:
                return ShiftOpening;
                case var value when value == ShiftClosure.Value:
                return ShiftClosure;
                case var value when value == UnscrapMaterial.Value:
                return UnscrapMaterial;
                case var value when value == RemoveFromTracking.Value:
                return RemoveFromTracking;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class GrooveCondition : GenericEnumType<short>
    {
        public static readonly GrooveCondition Undefined = new GrooveCondition(0, "Undefined");
        public static readonly GrooveCondition Clean = new GrooveCondition(1, "Clean");
        public static readonly GrooveCondition Dirty = new GrooveCondition(2, "Dirty");
        public static readonly GrooveCondition Invalid = new GrooveCondition(3, "Invalid");

        protected static Func<short, GrooveCondition> GetCustom;
        protected GrooveCondition(short value, string name) : base(value, name)
        {
        }

        protected static GrooveCondition GetInstance(short value, string name) => new GrooveCondition(value, name);
        public override string ToString() => $"GrooveCondition({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(GrooveCondition obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator GrooveCondition(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is GrooveCondition other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(GrooveCondition obj1, GrooveCondition obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(GrooveCondition obj1, GrooveCondition obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, GrooveCondition obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, GrooveCondition obj2) => !(obj1 == obj2);

        public static bool operator ==(GrooveCondition obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(GrooveCondition obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static GrooveCondition GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Clean.Value:
                return Clean;
                case var value when value == Dirty.Value:
                return Dirty;
                case var value when value == Invalid.Value:
                return Invalid;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ServiceType : GenericEnumType<short>
    {
        public static readonly ServiceType Undefined = new ServiceType(0, "Undefined");
        public static readonly ServiceType DateRelated = new ServiceType(1, "DateRelated");
        public static readonly ServiceType WeightRelated = new ServiceType(2, "WeightRelated");
        public static readonly ServiceType Both = new ServiceType(3, "Both");

        protected static Func<short, ServiceType> GetCustom;
        protected ServiceType(short value, string name) : base(value, name)
        {
        }

        protected static ServiceType GetInstance(short value, string name) => new ServiceType(value, name);
        public override string ToString() => $"ServiceType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ServiceType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ServiceType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ServiceType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ServiceType obj1, ServiceType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ServiceType obj1, ServiceType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ServiceType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ServiceType obj2) => !(obj1 == obj2);

        public static bool operator ==(ServiceType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ServiceType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ServiceType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == DateRelated.Value:
                return DateRelated;
                case var value when value == WeightRelated.Value:
                return WeightRelated;
                case var value when value == Both.Value:
                return Both;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CrashTest : GenericEnumType<short>
    {
        public static readonly CrashTest Undefined = new CrashTest(0, "Undefined");
        public static readonly CrashTest Good = new CrashTest(1, "Good");
        public static readonly CrashTest Bad = new CrashTest(2, "Bad");
        public static readonly CrashTest Doubtful = new CrashTest(3, "Doubtful");

        protected static Func<short, CrashTest> GetCustom;
        protected CrashTest(short value, string name) : base(value, name)
        {
        }

        protected static CrashTest GetInstance(short value, string name) => new CrashTest(value, name);
        public override string ToString() => $"CrashTest({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CrashTest obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CrashTest(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CrashTest other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CrashTest obj1, CrashTest obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CrashTest obj1, CrashTest obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CrashTest obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CrashTest obj2) => !(obj1 == obj2);

        public static bool operator ==(CrashTest obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CrashTest obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CrashTest GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Good.Value:
                return Good;
                case var value when value == Bad.Value:
                return Bad;
                case var value when value == Doubtful.Value:
                return Doubtful;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class InspectionResult : GenericEnumType<short>
    {
        public static readonly InspectionResult Undefined = new InspectionResult(0, "Undefined");
        public static readonly InspectionResult Good = new InspectionResult(1, "Good");
        public static readonly InspectionResult Bad = new InspectionResult(2, "Bad");
        public static readonly InspectionResult Doubtful = new InspectionResult(3, "Doubtful");

        protected static Func<short, InspectionResult> GetCustom;
        protected InspectionResult(short value, string name) : base(value, name)
        {
        }

        protected static InspectionResult GetInstance(short value, string name) => new InspectionResult(value, name);
        public override string ToString() => $"InspectionResult({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(InspectionResult obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator InspectionResult(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is InspectionResult other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(InspectionResult obj1, InspectionResult obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(InspectionResult obj1, InspectionResult obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, InspectionResult obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, InspectionResult obj2) => !(obj1 == obj2);

        public static bool operator ==(InspectionResult obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(InspectionResult obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static InspectionResult GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Good.Value:
                return Good;
                case var value when value == Bad.Value:
                return Bad;
                case var value when value == Doubtful.Value:
                return Doubtful;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class GrooveSetting : GenericEnumType<short>
    {
        public static readonly GrooveSetting Undefined = new GrooveSetting(0, "Undefined");
        public static readonly GrooveSetting Setting1 = new GrooveSetting(1, "Setting1");
        public static readonly GrooveSetting Setting2 = new GrooveSetting(2, "Setting2");
        public static readonly GrooveSetting Setting3 = new GrooveSetting(3, "Setting3");

        protected static Func<short, GrooveSetting> GetCustom;
        protected GrooveSetting(short value, string name) : base(value, name)
        {
        }

        protected static GrooveSetting GetInstance(short value, string name) => new GrooveSetting(value, name);
        public override string ToString() => $"GrooveSetting({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(GrooveSetting obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator GrooveSetting(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is GrooveSetting other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(GrooveSetting obj1, GrooveSetting obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(GrooveSetting obj1, GrooveSetting obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, GrooveSetting obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, GrooveSetting obj2) => !(obj1 == obj2);

        public static bool operator ==(GrooveSetting obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(GrooveSetting obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static GrooveSetting GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Setting1.Value:
                return Setting1;
                case var value when value == Setting2.Value:
                return Setting2;
                case var value when value == Setting3.Value:
                return Setting3;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class LayerType : GenericEnumType<short>
    {
        public static readonly LayerType Hot = new LayerType(0, "Hot");
        public static readonly LayerType Cold = new LayerType(1, "Cold");

        protected static Func<short, LayerType> GetCustom;
        protected LayerType(short value, string name) : base(value, name)
        {
        }

        protected static LayerType GetInstance(short value, string name) => new LayerType(value, name);
        public override string ToString() => $"LayerType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(LayerType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator LayerType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is LayerType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(LayerType obj1, LayerType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(LayerType obj1, LayerType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, LayerType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, LayerType obj2) => !(obj1 == obj2);

        public static bool operator ==(LayerType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(LayerType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static LayerType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Hot.Value:
                return Hot;
                case var value when value == Cold.Value:
                return Cold;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class LayerStatus : GenericEnumType<short>
    {
        public static readonly LayerStatus Undefined = new LayerStatus(0, "Undefined");
        public static readonly LayerStatus New = new LayerStatus(1, "New");
        public static readonly LayerStatus IsForming = new LayerStatus(2, "IsForming");
        public static readonly LayerStatus IsFormed = new LayerStatus(3, "IsFormed");
        public static readonly LayerStatus Transferred = new LayerStatus(4, "Transferred");

        protected static Func<short, LayerStatus> GetCustom;
        protected LayerStatus(short value, string name) : base(value, name)
        {
        }

        protected static LayerStatus GetInstance(short value, string name) => new LayerStatus(value, name);
        public override string ToString() => $"LayerStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(LayerStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator LayerStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is LayerStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(LayerStatus obj1, LayerStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(LayerStatus obj1, LayerStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, LayerStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, LayerStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(LayerStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(LayerStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static LayerStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == New.Value:
                return New;
                case var value when value == IsForming.Value:
                return IsForming;
                case var value when value == IsFormed.Value:
                return IsFormed;
                case var value when value == Transferred.Value:
                return Transferred;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class YardType : GenericEnumType<short>
    {
        public static readonly YardType Undefined = new YardType(0, "Undefined");
        public static readonly YardType MaterialYard = new YardType(10, "MaterialYard");
        public static readonly YardType MaterialReception = new YardType(12, "MaterialReception");
        public static readonly YardType MaterialScrap = new YardType(14, "MaterialScrap");
        public static readonly YardType MaterialCharging = new YardType(16, "MaterialCharging");
        public static readonly YardType ProductYard = new YardType(20, "ProductYard");
        public static readonly YardType ProductReception = new YardType(22, "ProductReception");
        public static readonly YardType ProductScrap = new YardType(24, "ProductScrap");
        public static readonly YardType ProductDespatch = new YardType(26, "ProductDespatch");
        public static readonly YardType Stack = new YardType(30, "Stack");
        public static readonly YardType Pile = new YardType(40, "Pile");

        protected static Func<short, YardType> GetCustom;
        protected YardType(short value, string name) : base(value, name)
        {
        }

        protected static YardType GetInstance(short value, string name) => new YardType(value, name);
        public override string ToString() => $"YardType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(YardType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator YardType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is YardType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(YardType obj1, YardType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(YardType obj1, YardType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, YardType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, YardType obj2) => !(obj1 == obj2);

        public static bool operator ==(YardType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(YardType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static YardType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == MaterialYard.Value:
                return MaterialYard;
                case var value when value == MaterialReception.Value:
                return MaterialReception;
                case var value when value == MaterialScrap.Value:
                return MaterialScrap;
                case var value when value == MaterialCharging.Value:
                return MaterialCharging;
                case var value when value == ProductYard.Value:
                return ProductYard;
                case var value when value == ProductReception.Value:
                return ProductReception;
                case var value when value == ProductScrap.Value:
                return ProductScrap;
                case var value when value == ProductDespatch.Value:
                return ProductDespatch;
                case var value when value == Stack.Value:
                return Stack;
                case var value when value == Pile.Value:
                return Pile;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class FillDirection : GenericEnumType<short>
    {
        public static readonly FillDirection Undefined = new FillDirection(0, "Undefined");
        public static readonly FillDirection Left2Right4Up2Down = new FillDirection(1, "Left2Right4Up2Down");
        public static readonly FillDirection Left2Right4Down2Up = new FillDirection(2, "Left2Right4Down2Up");
        public static readonly FillDirection Right2Left4Up2Down = new FillDirection(3, "Right2Left4Up2Down");
        public static readonly FillDirection Right2Left4Down2Up = new FillDirection(4, "Right2Left4Down2Up");

        protected static Func<short, FillDirection> GetCustom;
        protected FillDirection(short value, string name) : base(value, name)
        {
        }

        protected static FillDirection GetInstance(short value, string name) => new FillDirection(value, name);
        public override string ToString() => $"FillDirection({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(FillDirection obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator FillDirection(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is FillDirection other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(FillDirection obj1, FillDirection obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(FillDirection obj1, FillDirection obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, FillDirection obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, FillDirection obj2) => !(obj1 == obj2);

        public static bool operator ==(FillDirection obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(FillDirection obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static FillDirection GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Left2Right4Up2Down.Value:
                return Left2Right4Up2Down;
                case var value when value == Left2Right4Down2Up.Value:
                return Left2Right4Down2Up;
                case var value when value == Right2Left4Up2Down.Value:
                return Right2Left4Up2Down;
                case var value when value == Right2Left4Down2Up.Value:
                return Right2Left4Down2Up;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class FillPattern : GenericEnumType<short>
    {
        public static readonly FillPattern Undefined = new FillPattern(0, "Undefined");
        public static readonly FillPattern Perpendicular = new FillPattern(1, "Perpendicular");
        public static readonly FillPattern Parallel = new FillPattern(2, "Parallel");

        protected static Func<short, FillPattern> GetCustom;
        protected FillPattern(short value, string name) : base(value, name)
        {
        }

        protected static FillPattern GetInstance(short value, string name) => new FillPattern(value, name);
        public override string ToString() => $"FillPattern({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(FillPattern obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator FillPattern(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is FillPattern other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(FillPattern obj1, FillPattern obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(FillPattern obj1, FillPattern obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, FillPattern obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, FillPattern obj2) => !(obj1 == obj2);

        public static bool operator ==(FillPattern obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(FillPattern obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static FillPattern GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Perpendicular.Value:
                return Perpendicular;
                case var value when value == Parallel.Value:
                return Parallel;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class FurnaceNumber : GenericEnumType<short>
    {
        public static readonly FurnaceNumber Furnace1 = new FurnaceNumber(0, "Furnace1");
        public static readonly FurnaceNumber Furnace2 = new FurnaceNumber(1, "Furnace2");

        protected static Func<short, FurnaceNumber> GetCustom;
        protected FurnaceNumber(short value, string name) : base(value, name)
        {
        }

        protected static FurnaceNumber GetInstance(short value, string name) => new FurnaceNumber(value, name);
        public override string ToString() => $"FurnaceNumber({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(FurnaceNumber obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator FurnaceNumber(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is FurnaceNumber other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(FurnaceNumber obj1, FurnaceNumber obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(FurnaceNumber obj1, FurnaceNumber obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, FurnaceNumber obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, FurnaceNumber obj2) => !(obj1 == obj2);

        public static bool operator ==(FurnaceNumber obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(FurnaceNumber obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static FurnaceNumber GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Furnace1.Value:
                return Furnace1;
                case var value when value == Furnace2.Value:
                return Furnace2;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CrossChange : GenericEnumType<short>
    {
        public static readonly CrossChange Change1_2 = new CrossChange(0, "Change1_2");
        public static readonly CrossChange Change2_1 = new CrossChange(1, "Change2_1");

        protected static Func<short, CrossChange> GetCustom;
        protected CrossChange(short value, string name) : base(value, name)
        {
        }

        protected static CrossChange GetInstance(short value, string name) => new CrossChange(value, name);
        public override string ToString() => $"CrossChange({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CrossChange obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CrossChange(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CrossChange other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CrossChange obj1, CrossChange obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CrossChange obj1, CrossChange obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CrossChange obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CrossChange obj2) => !(obj1 == obj2);

        public static bool operator ==(CrossChange obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CrossChange obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CrossChange GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Change1_2.Value:
                return Change1_2;
                case var value when value == Change2_1.Value:
                return Change2_1;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class Severity : GenericEnumType<short>
    {
        public static readonly Severity Information = new Severity(0, "Information");
        public static readonly Severity Warning = new Severity(1, "Warning");
        public static readonly Severity Alarm = new Severity(2, "Alarm");

        protected static Func<short, Severity> GetCustom;
        protected Severity(short value, string name) : base(value, name)
        {
        }

        protected static Severity GetInstance(short value, string name) => new Severity(value, name);
        public override string ToString() => $"Severity({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(Severity obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator Severity(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is Severity other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(Severity obj1, Severity obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(Severity obj1, Severity obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, Severity obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, Severity obj2) => !(obj1 == obj2);

        public static bool operator ==(Severity obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(Severity obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static Severity GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Information.Value:
                return Information;
                case var value when value == Warning.Value:
                return Warning;
                case var value when value == Alarm.Value:
                return Alarm;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class ActionStatus : GenericEnumType<short>
    {
        public static readonly ActionStatus New = new ActionStatus(0, "New");
        public static readonly ActionStatus Approved = new ActionStatus(1, "Approved");
        public static readonly ActionStatus InRealization = new ActionStatus(2, "InRealization");
        public static readonly ActionStatus Done = new ActionStatus(3, "Done");
        public static readonly ActionStatus Canceled = new ActionStatus(4, "Canceled");
        public static readonly ActionStatus Deleted = new ActionStatus(5, "Deleted");

        protected static Func<short, ActionStatus> GetCustom;
        protected ActionStatus(short value, string name) : base(value, name)
        {
        }

        protected static ActionStatus GetInstance(short value, string name) => new ActionStatus(value, name);
        public override string ToString() => $"ActionStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(ActionStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator ActionStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is ActionStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(ActionStatus obj1, ActionStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(ActionStatus obj1, ActionStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, ActionStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, ActionStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(ActionStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(ActionStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static ActionStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == New.Value:
                return New;
                case var value when value == Approved.Value:
                return Approved;
                case var value when value == InRealization.Value:
                return InRealization;
                case var value when value == Done.Value:
                return Done;
                case var value when value == Canceled.Value:
                return Canceled;
                case var value when value == Deleted.Value:
                return Deleted;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class DeviceAvailability : GenericEnumType<short>
    {
        public static readonly DeviceAvailability Undefined = new DeviceAvailability(0, "Undefined");
        public static readonly DeviceAvailability Functional = new DeviceAvailability(1, "Functional");
        public static readonly DeviceAvailability Scrapped = new DeviceAvailability(2, "Scrapped");
        public static readonly DeviceAvailability Blocked = new DeviceAvailability(3, "Blocked");

        protected static Func<short, DeviceAvailability> GetCustom;
        protected DeviceAvailability(short value, string name) : base(value, name)
        {
        }

        protected static DeviceAvailability GetInstance(short value, string name) => new DeviceAvailability(value, name);
        public override string ToString() => $"DeviceAvailability({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(DeviceAvailability obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator DeviceAvailability(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is DeviceAvailability other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(DeviceAvailability obj1, DeviceAvailability obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(DeviceAvailability obj1, DeviceAvailability obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, DeviceAvailability obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, DeviceAvailability obj2) => !(obj1 == obj2);

        public static bool operator ==(DeviceAvailability obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(DeviceAvailability obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static DeviceAvailability GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Functional.Value:
                return Functional;
                case var value when value == Scrapped.Value:
                return Scrapped;
                case var value when value == Blocked.Value:
                return Blocked;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CommChannelType : GenericEnumType<short>
    {
        public static readonly CommChannelType Undefined = new CommChannelType(0, "Undefined");
        public static readonly CommChannelType OPC = new CommChannelType(1, "OPC");

        protected static Func<short, CommChannelType> GetCustom;
        protected CommChannelType(short value, string name) : base(value, name)
        {
        }

        protected static CommChannelType GetInstance(short value, string name) => new CommChannelType(value, name);
        public override string ToString() => $"CommChannelType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CommChannelType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CommChannelType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CommChannelType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CommChannelType obj1, CommChannelType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CommChannelType obj1, CommChannelType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CommChannelType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CommChannelType obj2) => !(obj1 == obj2);

        public static bool operator ==(CommChannelType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CommChannelType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CommChannelType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == OPC.Value:
                return OPC;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class FeatureType : GenericEnumType<short>
    {
        public static readonly FeatureType Undefined = new FeatureType(0, "Undefined");
        public static readonly FeatureType Tracking = new FeatureType(100, "Tracking");
        public static readonly FeatureType TrackingOccupied = new FeatureType(110, "TrackingOccupied");
        public static readonly FeatureType TrackingAreaModes = new FeatureType(120, "TrackingAreaModes");
        public static readonly FeatureType TrackingAreaModeProduction = new FeatureType(121, "TrackingAreaModeProduction");
        public static readonly FeatureType TrackingAreaModeAdjustion = new FeatureType(122, "TrackingAreaModeAdjustion");
        public static readonly FeatureType TrackingAreaSimulation = new FeatureType(123, "TrackingAreaSimulation");
        public static readonly FeatureType TrackingAreaAutomaticRelease = new FeatureType(124, "TrackingAreaAutomaticRelease");
        public static readonly FeatureType TrackingAreaEmpty = new FeatureType(125, "TrackingAreaEmpty");
        public static readonly FeatureType TrackingAreaCobbleDetected = new FeatureType(126, "TrackingAreaCobbleDetected");
        public static readonly FeatureType TrackingAreaModeLocal = new FeatureType(127, "TrackingAreaModeLocal");
        public static readonly FeatureType TrackingAreaCobbleDetectionSelected = new FeatureType(128, "TrackingAreaCobbleDetectionSelected");
        public static readonly FeatureType Measuring = new FeatureType(200, "Measuring");
        public static readonly FeatureType MeasuringSpeed = new FeatureType(210, "MeasuringSpeed");
        public static readonly FeatureType MeasuringHeadCutLength = new FeatureType(211, "MeasuringHeadCutLength");
        public static readonly FeatureType MeasuringTailCutLength = new FeatureType(212, "MeasuringTailCutLength");
        public static readonly FeatureType Consumption = new FeatureType(280, "Consumption");
        public static readonly FeatureType Temporary = new FeatureType(281, "Temporary");
        public static readonly FeatureType Growing = new FeatureType(282, "Growing");

        protected static Func<short, FeatureType> GetCustom;
        protected FeatureType(short value, string name) : base(value, name)
        {
        }

        protected static FeatureType GetInstance(short value, string name) => new FeatureType(value, name);
        public override string ToString() => $"FeatureType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(FeatureType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator FeatureType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is FeatureType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(FeatureType obj1, FeatureType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(FeatureType obj1, FeatureType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, FeatureType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, FeatureType obj2) => !(obj1 == obj2);

        public static bool operator ==(FeatureType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(FeatureType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static FeatureType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Tracking.Value:
                return Tracking;
                case var value when value == TrackingOccupied.Value:
                return TrackingOccupied;
                case var value when value == TrackingAreaModes.Value:
                return TrackingAreaModes;
                case var value when value == TrackingAreaModeProduction.Value:
                return TrackingAreaModeProduction;
                case var value when value == TrackingAreaModeAdjustion.Value:
                return TrackingAreaModeAdjustion;
                case var value when value == TrackingAreaSimulation.Value:
                return TrackingAreaSimulation;
                case var value when value == TrackingAreaAutomaticRelease.Value:
                return TrackingAreaAutomaticRelease;
                case var value when value == TrackingAreaEmpty.Value:
                return TrackingAreaEmpty;
                case var value when value == TrackingAreaCobbleDetected.Value:
                return TrackingAreaCobbleDetected;
                case var value when value == TrackingAreaModeLocal.Value:
                return TrackingAreaModeLocal;
                case var value when value == TrackingAreaCobbleDetectionSelected.Value:
                return TrackingAreaCobbleDetectionSelected;
                case var value when value == Measuring.Value:
                return Measuring;
                case var value when value == MeasuringSpeed.Value:
                return MeasuringSpeed;
                case var value when value == MeasuringHeadCutLength.Value:
                return MeasuringHeadCutLength;
                case var value when value == MeasuringTailCutLength.Value:
                return MeasuringTailCutLength;
                case var value when value == Consumption.Value:
                return Consumption;
                case var value when value == Temporary.Value:
                return Temporary;
                case var value when value == Growing.Value:
                return Growing;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class AggregationStrategy : GenericEnumType<short>
    {
        public static readonly AggregationStrategy Undefined = new AggregationStrategy(0, "Undefined");
        public static readonly AggregationStrategy Logical = new AggregationStrategy(1, "Logical");
        public static readonly AggregationStrategy FloatingPoint = new AggregationStrategy(2, "FloatingPoint");
        public static readonly AggregationStrategy IntValue = new AggregationStrategy(3, "IntValue");

        protected static Func<short, AggregationStrategy> GetCustom;
        protected AggregationStrategy(short value, string name) : base(value, name)
        {
        }

        protected static AggregationStrategy GetInstance(short value, string name) => new AggregationStrategy(value, name);
        public override string ToString() => $"AggregationStrategy({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(AggregationStrategy obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator AggregationStrategy(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is AggregationStrategy other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(AggregationStrategy obj1, AggregationStrategy obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(AggregationStrategy obj1, AggregationStrategy obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, AggregationStrategy obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, AggregationStrategy obj2) => !(obj1 == obj2);

        public static bool operator ==(AggregationStrategy obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(AggregationStrategy obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static AggregationStrategy GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Logical.Value:
                return Logical;
                case var value when value == FloatingPoint.Value:
                return FloatingPoint;
                case var value when value == IntValue.Value:
                return IntValue;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TrackingInstructionType : GenericEnumType<short>
    {
        public static readonly TrackingInstructionType Undefined = new TrackingInstructionType(0, "Undefined");
        public static readonly TrackingInstructionType Charge = new TrackingInstructionType(1, "Charge");
        public static readonly TrackingInstructionType Discharge = new TrackingInstructionType(2, "Discharge");
        public static readonly TrackingInstructionType UnCharge = new TrackingInstructionType(3, "UnCharge");
        public static readonly TrackingInstructionType UnDischarge = new TrackingInstructionType(4, "UnDischarge");
        public static readonly TrackingInstructionType MoveForward = new TrackingInstructionType(5, "MoveForward");
        public static readonly TrackingInstructionType MoveBackward = new TrackingInstructionType(6, "MoveBackward");
        public static readonly TrackingInstructionType RemoveVirtualPosition = new TrackingInstructionType(7, "RemoveVirtualPosition");
        public static readonly TrackingInstructionType Occupied = new TrackingInstructionType(8, "Occupied");
        public static readonly TrackingInstructionType ModeProduction = new TrackingInstructionType(9, "ModeProduction");
        public static readonly TrackingInstructionType ModeAdjustion = new TrackingInstructionType(10, "ModeAdjustion");
        public static readonly TrackingInstructionType Simulation = new TrackingInstructionType(11, "Simulation");
        public static readonly TrackingInstructionType AutomaticRelease = new TrackingInstructionType(12, "AutomaticRelease");
        public static readonly TrackingInstructionType Empty = new TrackingInstructionType(13, "Empty");
        public static readonly TrackingInstructionType CreateMaterialForQueue = new TrackingInstructionType(14, "CreateMaterialForQueue");
        public static readonly TrackingInstructionType Reject = new TrackingInstructionType(15, "Reject");
        public static readonly TrackingInstructionType RakeCycle = new TrackingInstructionType(16, "RakeCycle");
        public static readonly TrackingInstructionType ChargeToLayer = new TrackingInstructionType(17, "ChargeToLayer");
        public static readonly TrackingInstructionType LayerFormFinished = new TrackingInstructionType(18, "LayerFormFinished");
        public static readonly TrackingInstructionType LayerTransferred = new TrackingInstructionType(19, "LayerTransferred");
        public static readonly TrackingInstructionType GetVirtualPosition = new TrackingInstructionType(20, "GetVirtualPosition");
        public static readonly TrackingInstructionType AssignCTRMaterialInfo = new TrackingInstructionType(21, "AssignCTRMaterialInfo");
        public static readonly TrackingInstructionType ProcessAutoChopping = new TrackingInstructionType(22, "ProcessAutoChopping");
        public static readonly TrackingInstructionType ProcessManualChopping = new TrackingInstructionType(23, "ProcessManualChopping");
        public static readonly TrackingInstructionType ProcessHeadCut = new TrackingInstructionType(24, "ProcessHeadCut");
        public static readonly TrackingInstructionType ProcessTailCut = new TrackingInstructionType(25, "ProcessTailCut");
        public static readonly TrackingInstructionType ProcessEmergencyCut = new TrackingInstructionType(26, "ProcessEmergencyCut");
        public static readonly TrackingInstructionType ProcessSampleCut = new TrackingInstructionType(27, "ProcessSampleCut");
        public static readonly TrackingInstructionType ProcessDivideCut = new TrackingInstructionType(28, "ProcessDivideCut");
        public static readonly TrackingInstructionType CobbleDetected = new TrackingInstructionType(29, "CobbleDetected");
        public static readonly TrackingInstructionType CalculatePartialScrapForShear = new TrackingInstructionType(30, "CalculatePartialScrapForShear");
        public static readonly TrackingInstructionType RemoveFromGrey = new TrackingInstructionType(31, "RemoveFromGrey");
        public static readonly TrackingInstructionType CreateChildMaterial = new TrackingInstructionType(32, "CreateChildMaterial");
        public static readonly TrackingInstructionType GetLastVisitedMaterialByPointAssetCode = new TrackingInstructionType(33, "GetLastVisitedMaterialByPointAssetCode");
        public static readonly TrackingInstructionType CreateCollectionElement = new TrackingInstructionType(34, "CreateCollectionElement");
        public static readonly TrackingInstructionType LastDivideVerification = new TrackingInstructionType(35, "LastDivideVerification");
        public static readonly TrackingInstructionType CreateChildCtrMaterial = new TrackingInstructionType(36, "CreateChildCtrMaterial");
        public static readonly TrackingInstructionType SetEnterTs = new TrackingInstructionType(37, "SetEnterTs");
        public static readonly TrackingInstructionType SetCorrelationId = new TrackingInstructionType(38, "SetCorrelationId");
        public static readonly TrackingInstructionType AssignCorrelationIdToMaterialInfo = new TrackingInstructionType(39, "AssignCorrelationIdToMaterialInfo");
        public static readonly TrackingInstructionType DischargeElementByCorrelationId = new TrackingInstructionType(40, "DischargeElementByCorrelationId");
        public static readonly TrackingInstructionType ChargeWithPreventOverflow = new TrackingInstructionType(41, "ChargeWithPreventOverflow");
        public static readonly TrackingInstructionType WeighingStationWeightNDR = new TrackingInstructionType(42, "WeighingStationWeightNDR");
        public static readonly TrackingInstructionType PrintLabel = new TrackingInstructionType(43, "PrintLabel");
        public static readonly TrackingInstructionType ModeLocal = new TrackingInstructionType(44, "ModeLocal");
        public static readonly TrackingInstructionType CobbleDetectionSelected = new TrackingInstructionType(45, "CobbleDetectionSelected");
        public static readonly TrackingInstructionType CageClosed = new TrackingInstructionType(46, "CageClosed");

        protected static Func<short, TrackingInstructionType> GetCustom;
        protected TrackingInstructionType(short value, string name) : base(value, name)
        {
        }

        protected static TrackingInstructionType GetInstance(short value, string name) => new TrackingInstructionType(value, name);
        public override string ToString() => $"TrackingInstructionType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TrackingInstructionType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TrackingInstructionType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TrackingInstructionType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TrackingInstructionType obj1, TrackingInstructionType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TrackingInstructionType obj1, TrackingInstructionType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TrackingInstructionType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TrackingInstructionType obj2) => !(obj1 == obj2);

        public static bool operator ==(TrackingInstructionType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TrackingInstructionType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TrackingInstructionType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Charge.Value:
                return Charge;
                case var value when value == Discharge.Value:
                return Discharge;
                case var value when value == UnCharge.Value:
                return UnCharge;
                case var value when value == UnDischarge.Value:
                return UnDischarge;
                case var value when value == MoveForward.Value:
                return MoveForward;
                case var value when value == MoveBackward.Value:
                return MoveBackward;
                case var value when value == RemoveVirtualPosition.Value:
                return RemoveVirtualPosition;
                case var value when value == Occupied.Value:
                return Occupied;
                case var value when value == ModeProduction.Value:
                return ModeProduction;
                case var value when value == ModeAdjustion.Value:
                return ModeAdjustion;
                case var value when value == Simulation.Value:
                return Simulation;
                case var value when value == AutomaticRelease.Value:
                return AutomaticRelease;
                case var value when value == Empty.Value:
                return Empty;
                case var value when value == CreateMaterialForQueue.Value:
                return CreateMaterialForQueue;
                case var value when value == Reject.Value:
                return Reject;
                case var value when value == RakeCycle.Value:
                return RakeCycle;
                case var value when value == ChargeToLayer.Value:
                return ChargeToLayer;
                case var value when value == LayerFormFinished.Value:
                return LayerFormFinished;
                case var value when value == LayerTransferred.Value:
                return LayerTransferred;
                case var value when value == GetVirtualPosition.Value:
                return GetVirtualPosition;
                case var value when value == AssignCTRMaterialInfo.Value:
                return AssignCTRMaterialInfo;
                case var value when value == ProcessAutoChopping.Value:
                return ProcessAutoChopping;
                case var value when value == ProcessManualChopping.Value:
                return ProcessManualChopping;
                case var value when value == ProcessHeadCut.Value:
                return ProcessHeadCut;
                case var value when value == ProcessTailCut.Value:
                return ProcessTailCut;
                case var value when value == ProcessEmergencyCut.Value:
                return ProcessEmergencyCut;
                case var value when value == ProcessSampleCut.Value:
                return ProcessSampleCut;
                case var value when value == ProcessDivideCut.Value:
                return ProcessDivideCut;
                case var value when value == CobbleDetected.Value:
                return CobbleDetected;
                case var value when value == CalculatePartialScrapForShear.Value:
                return CalculatePartialScrapForShear;
                case var value when value == RemoveFromGrey.Value:
                return RemoveFromGrey;
                case var value when value == CreateChildMaterial.Value:
                return CreateChildMaterial;
                case var value when value == GetLastVisitedMaterialByPointAssetCode.Value:
                return GetLastVisitedMaterialByPointAssetCode;
                case var value when value == CreateCollectionElement.Value:
                return CreateCollectionElement;
                case var value when value == LastDivideVerification.Value:
                return LastDivideVerification;
                case var value when value == CreateChildCtrMaterial.Value:
                return CreateChildCtrMaterial;
                case var value when value == SetEnterTs.Value:
                return SetEnterTs;
                case var value when value == SetCorrelationId.Value:
                return SetCorrelationId;
                case var value when value == AssignCorrelationIdToMaterialInfo.Value:
                return AssignCorrelationIdToMaterialInfo;
                case var value when value == DischargeElementByCorrelationId.Value:
                return DischargeElementByCorrelationId;
                case var value when value == ChargeWithPreventOverflow.Value:
                return ChargeWithPreventOverflow;
                case var value when value == WeighingStationWeightNDR.Value:
                return WeighingStationWeightNDR;
                case var value when value == PrintLabel.Value:
                return PrintLabel;
                case var value when value == ModeLocal.Value:
                return ModeLocal;
                case var value when value == CobbleDetectionSelected.Value:
                return CobbleDetectionSelected;
                case var value when value == CageClosed.Value:
                return CageClosed;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TrackingAreaType : GenericEnumType<short>
    {
        public static readonly TrackingAreaType None = new TrackingAreaType(0, "None");
        public static readonly TrackingAreaType CTR = new TrackingAreaType(1, "CTR");
        public static readonly TrackingAreaType Collection = new TrackingAreaType(2, "Collection");

        protected static Func<short, TrackingAreaType> GetCustom;
        protected TrackingAreaType(short value, string name) : base(value, name)
        {
        }

        protected static TrackingAreaType GetInstance(short value, string name) => new TrackingAreaType(value, name);
        public override string ToString() => $"TrackingAreaType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TrackingAreaType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TrackingAreaType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TrackingAreaType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TrackingAreaType obj1, TrackingAreaType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TrackingAreaType obj1, TrackingAreaType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TrackingAreaType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TrackingAreaType obj2) => !(obj1 == obj2);

        public static bool operator ==(TrackingAreaType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TrackingAreaType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TrackingAreaType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == None.Value:
                return None;
                case var value when value == CTR.Value:
                return CTR;
                case var value when value == Collection.Value:
                return Collection;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TrackingArea : GenericEnumType<int>
    {
        public static readonly TrackingArea Undefined = new TrackingArea(0, "Undefined");
        public static readonly TrackingArea PLANT = new TrackingArea(1, "PLANT");
        public static readonly TrackingArea BILLET_YARD = new TrackingArea(1000000, "BILLET_YARD");
        public static readonly TrackingArea BILLET_RECEPTION = new TrackingArea(1100000, "BILLET_RECEPTION");
        public static readonly TrackingArea SCRAPPED_BILLET_YARD = new TrackingArea(1200000, "SCRAPPED_BILLET_YARD");
        public static readonly TrackingArea BILLET_YARD_1 = new TrackingArea(1300000, "BILLET_YARD_1");
        public static readonly TrackingArea MATERIAL_CHARGING = new TrackingArea(1400000, "MATERIAL_CHARGING");
        public static readonly TrackingArea BILLET_YARD_2 = new TrackingArea(1550000, "BILLET_YARD_2");
        public static readonly TrackingArea PRE_PROCESSING = new TrackingArea(3000000, "PRE_PROCESSING");
        public static readonly TrackingArea CHG_AREA = new TrackingArea(3100000, "CHG_AREA");
        public static readonly TrackingArea FCE_AREA = new TrackingArea(3200000, "FCE_AREA");
        public static readonly TrackingArea PROCESSING = new TrackingArea(5000000, "PROCESSING");
        public static readonly TrackingArea BDM_AREA = new TrackingArea(5100000, "BDM_AREA");
        public static readonly TrackingArea RM_AREA = new TrackingArea(5200000, "RM_AREA");
        public static readonly TrackingArea IM_AREA = new TrackingArea(5300000, "IM_AREA");
        public static readonly TrackingArea PRE_FM_AREA = new TrackingArea(5400000, "PRE_FM_AREA");
        public static readonly TrackingArea FM_AREA = new TrackingArea(5500000, "FM_AREA");
        public static readonly TrackingArea PST_FM_AREA = new TrackingArea(5600000, "PST_FM_AREA");
        public static readonly TrackingArea ROD_AREA = new TrackingArea(5700000, "ROD_AREA");
        public static readonly TrackingArea GREY_AREA = new TrackingArea(5900000, "GREY_AREA");
        public static readonly TrackingArea GARRET_AREA = new TrackingArea(6050000, "GARRET_AREA");
        public static readonly TrackingArea STELMOR_AREA = new TrackingArea(6250000, "STELMOR_AREA");
        public static readonly TrackingArea REFORM_AREA = new TrackingArea(6300000, "REFORM_AREA");
        public static readonly TrackingArea POST_PROCESSING = new TrackingArea(7000000, "POST_PROCESSING");
        public static readonly TrackingArea CB_AREA = new TrackingArea(7100000, "CB_AREA");
        public static readonly TrackingArea ENTER_TABLE_AREA = new TrackingArea(7400000, "ENTER_TABLE_AREA");
        public static readonly TrackingArea RAKE_AREA = new TrackingArea(7500000, "RAKE_AREA");
        public static readonly TrackingArea LAYER_AREA = new TrackingArea(7600000, "LAYER_AREA");
        public static readonly TrackingArea BAR_WEIGHING_AREA = new TrackingArea(7700000, "BAR_WEIGHING_AREA");
        public static readonly TrackingArea COIL_WEIGHING_AREA = new TrackingArea(7800000, "COIL_WEIGHING_AREA");
        public static readonly TrackingArea TRANSPORT_AREA = new TrackingArea(7900000, "TRANSPORT_AREA");
        public static readonly TrackingArea PRODUCT_YARD = new TrackingArea(9000000, "PRODUCT_YARD");
        public static readonly TrackingArea PRODUCT_RECEPTION = new TrackingArea(9100000, "PRODUCT_RECEPTION");
        public static readonly TrackingArea SCRAPPED_PRODUCT_YARD = new TrackingArea(9200000, "SCRAPPED_PRODUCT_YARD");
        public static readonly TrackingArea PRODUCT_YARD_1 = new TrackingArea(9300000, "PRODUCT_YARD_1");
        public static readonly TrackingArea PRODUCT_DESPATCH = new TrackingArea(9400000, "PRODUCT_DESPATCH");
        public static readonly TrackingArea PRODUCT_YARD_2 = new TrackingArea(9550000, "PRODUCT_YARD_2");

        protected static Func<int, TrackingArea> GetCustom;
        protected TrackingArea(int value, string name) : base(value, name)
        {
        }

        protected static TrackingArea GetInstance(int value, string name) => new TrackingArea(value, name);
        public override string ToString() => $"TrackingArea({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int32;
        public override int ToInt32(IFormatProvider provider) => this.Value;

        public static implicit operator int(TrackingArea obj) => obj != null ? obj.Value : (int) 0;

        public static explicit operator TrackingArea(int input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TrackingArea other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TrackingArea obj1, TrackingArea obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TrackingArea obj1, TrackingArea obj2) => !(obj1 == obj2);

        public static bool operator ==(int obj1, TrackingArea obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(int obj1, TrackingArea obj2) => !(obj1 == obj2);

        public static bool operator ==(TrackingArea obj1, int obj2) => obj2 == obj1;

        public static bool operator !=(TrackingArea obj1, int obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TrackingArea GetValue(int input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == PLANT.Value:
                return PLANT;
                case var value when value == BILLET_YARD.Value:
                return BILLET_YARD;
                case var value when value == BILLET_RECEPTION.Value:
                return BILLET_RECEPTION;
                case var value when value == SCRAPPED_BILLET_YARD.Value:
                return SCRAPPED_BILLET_YARD;
                case var value when value == BILLET_YARD_1.Value:
                return BILLET_YARD_1;
                case var value when value == MATERIAL_CHARGING.Value:
                return MATERIAL_CHARGING;
                case var value when value == BILLET_YARD_2.Value:
                return BILLET_YARD_2;
                case var value when value == PRE_PROCESSING.Value:
                return PRE_PROCESSING;
                case var value when value == CHG_AREA.Value:
                return CHG_AREA;
                case var value when value == FCE_AREA.Value:
                return FCE_AREA;
                case var value when value == PROCESSING.Value:
                return PROCESSING;
                case var value when value == BDM_AREA.Value:
                return BDM_AREA;
                case var value when value == RM_AREA.Value:
                return RM_AREA;
                case var value when value == IM_AREA.Value:
                return IM_AREA;
                case var value when value == PRE_FM_AREA.Value:
                return PRE_FM_AREA;
                case var value when value == FM_AREA.Value:
                return FM_AREA;
                case var value when value == PST_FM_AREA.Value:
                return PST_FM_AREA;
                case var value when value == ROD_AREA.Value:
                return ROD_AREA;
                case var value when value == GREY_AREA.Value:
                return GREY_AREA;
                case var value when value == GARRET_AREA.Value:
                return GARRET_AREA;
                case var value when value == STELMOR_AREA.Value:
                return STELMOR_AREA;
                case var value when value == REFORM_AREA.Value:
                return REFORM_AREA;
                case var value when value == POST_PROCESSING.Value:
                return POST_PROCESSING;
                case var value when value == CB_AREA.Value:
                return CB_AREA;
                case var value when value == ENTER_TABLE_AREA.Value:
                return ENTER_TABLE_AREA;
                case var value when value == RAKE_AREA.Value:
                return RAKE_AREA;
                case var value when value == LAYER_AREA.Value:
                return LAYER_AREA;
                case var value when value == BAR_WEIGHING_AREA.Value:
                return BAR_WEIGHING_AREA;
                case var value when value == COIL_WEIGHING_AREA.Value:
                return COIL_WEIGHING_AREA;
                case var value when value == TRANSPORT_AREA.Value:
                return TRANSPORT_AREA;
                case var value when value == PRODUCT_YARD.Value:
                return PRODUCT_YARD;
                case var value when value == PRODUCT_RECEPTION.Value:
                return PRODUCT_RECEPTION;
                case var value when value == SCRAPPED_PRODUCT_YARD.Value:
                return SCRAPPED_PRODUCT_YARD;
                case var value when value == PRODUCT_YARD_1.Value:
                return PRODUCT_YARD_1;
                case var value when value == PRODUCT_DESPATCH.Value:
                return PRODUCT_DESPATCH;
                case var value when value == PRODUCT_YARD_2.Value:
                return PRODUCT_YARD_2;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TriggerType : GenericEnumType<short>
    {
        public static readonly TriggerType Undefined = new TriggerType(0, "Undefined");

        protected static Func<short, TriggerType> GetCustom;
        protected TriggerType(short value, string name) : base(value, name)
        {
        }

        protected static TriggerType GetInstance(short value, string name) => new TriggerType(value, name);
        public override string ToString() => $"TriggerType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TriggerType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TriggerType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TriggerType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TriggerType obj1, TriggerType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TriggerType obj1, TriggerType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TriggerType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TriggerType obj2) => !(obj1 == obj2);

        public static bool operator ==(TriggerType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TriggerType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TriggerType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class KPIType : GenericEnumType<short>
    {
        public static readonly KPIType Undefined = new KPIType(0, "Undefined");
        public static readonly KPIType WOMY = new KPIType(1, "WOMY");
        public static readonly KPIType WOQY = new KPIType(3, "WOQY");
        public static readonly KPIType WOC = new KPIType(4, "WOC");
        public static readonly KPIType OEE = new KPIType(5, "OEE");

        protected static Func<short, KPIType> GetCustom;
        protected KPIType(short value, string name) : base(value, name)
        {
        }

        protected static KPIType GetInstance(short value, string name) => new KPIType(value, name);
        public override string ToString() => $"KPIType({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(KPIType obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator KPIType(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is KPIType other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(KPIType obj1, KPIType obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(KPIType obj1, KPIType obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, KPIType obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, KPIType obj2) => !(obj1 == obj2);

        public static bool operator ==(KPIType obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(KPIType obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static KPIType GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == WOMY.Value:
                return WOMY;
                case var value when value == WOQY.Value:
                return WOQY;
                case var value when value == WOC.Value:
                return WOC;
                case var value when value == OEE.Value:
                return OEE;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class GrooveTemplateStatus : GenericEnumType<short>
    {
        public static readonly GrooveTemplateStatus Undefined = new GrooveTemplateStatus(0, "Undefined");
        public static readonly GrooveTemplateStatus Clean = new GrooveTemplateStatus(1, "Clean");
        public static readonly GrooveTemplateStatus Dirty = new GrooveTemplateStatus(2, "Dirty");
        public static readonly GrooveTemplateStatus Invalid = new GrooveTemplateStatus(3, "Invalid");
        public static readonly GrooveTemplateStatus History = new GrooveTemplateStatus(99, "History");

        protected static Func<short, GrooveTemplateStatus> GetCustom;
        protected GrooveTemplateStatus(short value, string name) : base(value, name)
        {
        }

        protected static GrooveTemplateStatus GetInstance(short value, string name) => new GrooveTemplateStatus(value, name);
        public override string ToString() => $"GrooveTemplateStatus({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(GrooveTemplateStatus obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator GrooveTemplateStatus(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is GrooveTemplateStatus other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(GrooveTemplateStatus obj1, GrooveTemplateStatus obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(GrooveTemplateStatus obj1, GrooveTemplateStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, GrooveTemplateStatus obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, GrooveTemplateStatus obj2) => !(obj1 == obj2);

        public static bool operator ==(GrooveTemplateStatus obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(GrooveTemplateStatus obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static GrooveTemplateStatus GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Clean.Value:
                return Clean;
                case var value when value == Dirty.Value:
                return Dirty;
                case var value when value == Invalid.Value:
                return Invalid;
                case var value when value == History.Value:
                return History;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class FeatureProvider : GenericEnumType<short>
    {
        public static readonly FeatureProvider Undefined = new FeatureProvider(0, "Undefined");
        public static readonly FeatureProvider L1 = new FeatureProvider(1, "L1");
        public static readonly FeatureProvider Furnace = new FeatureProvider(2, "Furnace");
        public static readonly FeatureProvider ProcessExpert = new FeatureProvider(3, "ProcessExpert");

        protected static Func<short, FeatureProvider> GetCustom;
        protected FeatureProvider(short value, string name) : base(value, name)
        {
        }

        protected static FeatureProvider GetInstance(short value, string name) => new FeatureProvider(value, name);
        public override string ToString() => $"FeatureProvider({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(FeatureProvider obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator FeatureProvider(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is FeatureProvider other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(FeatureProvider obj1, FeatureProvider obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(FeatureProvider obj1, FeatureProvider obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, FeatureProvider obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, FeatureProvider obj2) => !(obj1 == obj2);

        public static bool operator ==(FeatureProvider obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(FeatureProvider obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static FeatureProvider GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == L1.Value:
                return L1;
                case var value when value == Furnace.Value:
                return Furnace;
                case var value when value == ProcessExpert.Value:
                return ProcessExpert;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class TagValidationResult : GenericEnumType<short>
    {
        public static readonly TagValidationResult Undefined = new TagValidationResult(0, "Undefined");
        public static readonly TagValidationResult Valid = new TagValidationResult(1, "Valid");
        public static readonly TagValidationResult OpcServerNotAvailable = new TagValidationResult(2, "OpcServerNotAvailable");
        public static readonly TagValidationResult NotFound = new TagValidationResult(3, "NotFound");
        public static readonly TagValidationResult AvailableOnAnotherServer = new TagValidationResult(4, "AvailableOnAnotherServer");

        protected static Func<short, TagValidationResult> GetCustom;
        protected TagValidationResult(short value, string name) : base(value, name)
        {
        }

        protected static TagValidationResult GetInstance(short value, string name) => new TagValidationResult(value, name);
        public override string ToString() => $"TagValidationResult({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(TagValidationResult obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator TagValidationResult(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is TagValidationResult other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(TagValidationResult obj1, TagValidationResult obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(TagValidationResult obj1, TagValidationResult obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, TagValidationResult obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, TagValidationResult obj2) => !(obj1 == obj2);

        public static bool operator ==(TagValidationResult obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(TagValidationResult obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static TagValidationResult GetValue(short input)
        {
            switch(input)
            {
                case var value when value == Undefined.Value:
                return Undefined;
                case var value when value == Valid.Value:
                return Valid;
                case var value when value == OpcServerNotAvailable.Value:
                return OpcServerNotAvailable;
                case var value when value == NotFound.Value:
                return NotFound;
                case var value when value == AvailableOnAnotherServer.Value:
                return AvailableOnAnotherServer;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class CompareOperator : GenericEnumType<short>
    {
        public static readonly CompareOperator None = new CompareOperator(0, "None");
        public static readonly CompareOperator Equal = new CompareOperator(1, "Equal");
        public static readonly CompareOperator NonEqual = new CompareOperator(2, "NonEqual");
        public static readonly CompareOperator Greater = new CompareOperator(3, "Greater");
        public static readonly CompareOperator Less = new CompareOperator(4, "Less");
        public static readonly CompareOperator GreaterOrEqual = new CompareOperator(5, "GreaterOrEqual");
        public static readonly CompareOperator LessOrEqual = new CompareOperator(6, "LessOrEqual");

        protected static Func<short, CompareOperator> GetCustom;
        protected CompareOperator(short value, string name) : base(value, name)
        {
        }

        protected static CompareOperator GetInstance(short value, string name) => new CompareOperator(value, name);
        public override string ToString() => $"CompareOperator({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(CompareOperator obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator CompareOperator(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is CompareOperator other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(CompareOperator obj1, CompareOperator obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(CompareOperator obj1, CompareOperator obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, CompareOperator obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, CompareOperator obj2) => !(obj1 == obj2);

        public static bool operator ==(CompareOperator obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(CompareOperator obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static CompareOperator GetValue(short input)
        {
            switch(input)
            {
                case var value when value == None.Value:
                return None;
                case var value when value == Equal.Value:
                return Equal;
                case var value when value == NonEqual.Value:
                return NonEqual;
                case var value when value == Greater.Value:
                return Greater;
                case var value when value == Less.Value:
                return Less;
                case var value when value == GreaterOrEqual.Value:
                return GreaterOrEqual;
                case var value when value == LessOrEqual.Value:
                return LessOrEqual;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

    [Serializable]
    public class LogicalOperator : GenericEnumType<short>
    {
        public static readonly LogicalOperator None = new LogicalOperator(0, "None");
        public static readonly LogicalOperator And = new LogicalOperator(1, "And");
        public static readonly LogicalOperator Or = new LogicalOperator(2, "Or");

        protected static Func<short, LogicalOperator> GetCustom;
        protected LogicalOperator(short value, string name) : base(value, name)
        {
        }

        protected static LogicalOperator GetInstance(short value, string name) => new LogicalOperator(value, name);
        public override string ToString() => $"LogicalOperator({Name})";
        public override TypeCode GetTypeCode() => TypeCode.Int16;
        public override short ToInt16(IFormatProvider provider) => this.Value;

        public static implicit operator short(LogicalOperator obj) => obj != null ? obj.Value : (short) 0;

        public static explicit operator LogicalOperator(short input) => GetValue(input);

        public override bool Equals(object obj)
        {
            if (obj is LogicalOperator other)
            {
                return other.Value == this.Value;
            }

            return false;
        }
        public static bool operator ==(LogicalOperator obj1, LogicalOperator obj2)
        {
            if (ReferenceEquals(obj1, obj2))
            {
                return true;
            }
            if (ReferenceEquals(obj1, null))
            {
                return false;
            }
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1.Equals(obj2);
        }

        public static bool operator !=(LogicalOperator obj1, LogicalOperator obj2) => !(obj1 == obj2);

        public static bool operator ==(short obj1, LogicalOperator obj2)
        {
            if (ReferenceEquals(obj2, null))
            {
                return false;
            }

            return obj1 == obj2.Value;
        }

        public static bool operator !=(short obj1, LogicalOperator obj2) => !(obj1 == obj2);

        public static bool operator ==(LogicalOperator obj1, short obj2) => obj2 == obj1;

        public static bool operator !=(LogicalOperator obj1, short obj2) => !(obj1 == obj2);

        public override int GetHashCode() => base.GetHashCode();

        public static LogicalOperator GetValue(short input)
        {
            switch(input)
            {
                case var value when value == None.Value:
                return None;
                case var value when value == And.Value:
                return And;
                case var value when value == Or.Value:
                return Or;
                default:
                return GetCustom?.Invoke(input) ?? throw new ArgumentOutOfRangeException(input.ToString());
            }
        }
    }

}
